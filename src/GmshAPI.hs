{- 
GmshAPI.hs - GMSH C API for Haskell. 
Api version: 4.4
GmshAPI.hs - GMSH C API.
Copyright (C) 2019  Antero Marjamäki

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License ("LICENSE" file) for more details.

This file is automatically generated. DO NOT EDIT DIRECTLY!
-}

module GmshAPI where

import Control.Monad (liftM)
import Foreign.C -- get the C types
import Foreign.Ptr (Ptr,nullPtr)
import Foreign.C.String (withCString, peekCString)
import Foreign.Marshal (alloca, fromBool)
import Foreign.Marshal.Utils (withMany)
import Foreign.Marshal.Array (withArray, peekArray, advancePtr, withArrayLen)
import Foreign.Storable (peek, Storable)
import Data.Maybe (fromMaybe)
import Debug.Trace (trace)

toInt :: Ptr CInt -> IO Int
toInt = liftM fromIntegral . peek

-- marshaller for argv type "char ** argv"
withArgv :: [String] -> (Ptr CString -> IO a) -> IO a
withArgv ss f = withMany withCString ss f'
   where
      f' x = withArray x f


withArrayArrayLen
   :: (Storable a )
   => [[a]]
   -> (CInt -> Ptr CInt -> Ptr (Ptr a) -> IO(b))
   -> IO (b)
withArrayArrayLen arr f = do
   let len = fromIntegral $ length arr
   let lens = map fromIntegral $ map length arr
   withMany withArray arr $ \marr -> do
      -- marr :: [Ptr a]
      withArray marr $ \mmarr -> do
         --mmarr :: Ptr (Ptr a), toivottavasti
         withArray lens $ \larr -> do
            f len larr mmarr

withArrayArrayIntLen
   :: [[Int]]
   -> (CInt -> Ptr CInt -> Ptr (Ptr CInt) -> IO(b))
   -> IO (b)

withArrayArrayIntLen arr =
   let arr' = map (map fromIntegral) arr
   in withArrayArrayLen arr'

withArrayArrayDoubleLen
   :: [[Double]]
   -> (CInt -> Ptr CInt -> Ptr (Ptr CDouble) -> IO(b))
   -> IO (b)

withArrayArrayDoubleLen arr =
   let arr' = map (map realToFrac) arr
   in withArrayArrayLen arr'

withArrayIntLen :: [Int] -> (CInt -> Ptr CInt -> IO(b)) -> IO(b)
withArrayIntLen arr f =
    let arr' = map fromIntegral arr
        f' len ptr = f (fromIntegral len) ptr
    in withArrayLen arr' f'


withArrayPairLen
    :: [(Int, Int)]
    -> (CInt -> Ptr CInt -> IO(b))
    -> IO(b)

withArrayPairLen arr f =
    let arr' = map fromIntegral $ pairsToFlat arr
    in
        withArrayLen arr' $ \narr arr'' -> do
            f (fromIntegral narr) arr''

withArrayDoubleLen :: [Double] -> (CInt -> Ptr CDouble -> IO(b)) -> IO(b)
withArrayDoubleLen arr f =
    let arr' = map realToFrac arr
        f' len ptr = f (fromIntegral len) ptr
    in withArrayLen arr' f'

withArrayStringLen :: [String] -> (CInt -> Ptr CString -> IO(b)) -> IO(b)
withArrayStringLen strs f = do
    let len = fromIntegral $ length strs
    withMany withCString strs $ \marr -> do
        -- marr :: [CString]
        withArray marr $ \mmarr -> do
            -- mmarr :: Ptr CString hopefully!
            f len mmarr

peekInt :: Ptr CInt -> IO(Int)
peekInt = liftM fromIntegral . peek

peekArrayString :: Ptr CInt -> Ptr (Ptr CString) -> IO([String])
peekArrayString nptr arrptr = do
    nstrs <- peekInt nptr
    arr <- peek arrptr
    strings <- peekArray nstrs arr
    sequence $ map peekCString strings


flatToPairs :: [a] -> [(a,a)]
flatToPairs [] = []
flatToPairs (x:y:[]) = [(x,y)]
flatToPairs (x:y:xs) = (x,y) : flatToPairs xs

pairsToFlat :: [(a,a)] -> [a]
pairsToFlat lst = reverse $ foldl (\acc (a,b) -> b:a:acc) [] lst


-- Ptr (Ptr CInt) is a serialized list of integers, i.e.
-- **int is a pointer to an array, not an array of arrays... D'OH!
peekArrayPairs :: Ptr CInt -> Ptr (Ptr CInt) -> IO([(Int, Int)])
peekArrayPairs nptr arrptr  = do
  npairs <- peekInt nptr
  arr <- peek arrptr
  flatpairs <- peekArray npairs arr
  return $ flatToPairs $ map fromIntegral flatpairs

peekArrayInt :: Ptr CInt -> Ptr (Ptr CInt) -> IO([Int])
peekArrayInt nptr arrptr  = do
  nints <- peekInt nptr
  arr <- peek arrptr
  ints <- peekArray nints arr
  return $ map fromIntegral ints

peekArrayDouble :: Ptr CInt -> Ptr (Ptr CDouble) -> IO([Double])
peekArrayDouble nptr arrptr  = do
    nints <- peekInt nptr
    arr <- peek arrptr
    ints <- peekArray nints arr
    return $ map realToFrac ints


peekArrayArray
    :: (Storable a)
    => ([a] -> [b])
    -> Ptr CInt
    -> Ptr (Ptr CInt)
    -> Ptr (Ptr (Ptr a))
    -> IO ([[b]])
-- Peeks a nested array and uses f to map the
-- result to correct datatype
peekArrayArray f nnPtr nPtr arrPtrPtr  =
  do
    nn <- peekInt nnPtr
    narr <- peek nPtr
    lens <- peekArray nn narr
    arrPtr <- peek arrPtrPtr
    -- okay, so. fold over the list of lengths, lens.
    -- For each element dereference the pointer
    -- then peek n elements from the array, then advance the outer pointer
    -- accumulate the list of peeked lists, and the advanced pointer
    (lists,_) <- foldl foldfun (return ([], arrPtr)) $ map fromIntegral lens
    return lists

  where
    -- foldfun takes the previous IO action and runs it,
    -- then proceeds to peek and advance ptrs and maps the
    -- result using f
    foldfun action n = do
        (acc, ptr) <- action
        aptr <- peek ptr
        lst <- peekArray n aptr
        let out = f lst
        --let pairss = flatToPairs $ map fromIntegral lst
        let newptr = advancePtr ptr 1
        return ((out:acc), newptr)

peekArrayArrayInt
  :: Ptr CInt
  -> Ptr (Ptr CInt)
  -> Ptr (Ptr (Ptr CInt))
  -> IO([[Int]])
peekArrayArrayInt = peekArrayArray $ map fromIntegral

peekArrayArrayDouble
  :: Ptr CInt
  -> Ptr (Ptr CInt)
  -> Ptr (Ptr (Ptr CDouble))
  -> IO([[Double]])
peekArrayArrayDouble = peekArrayArray $ map realToFrac

peekArrayArrayPairs
  :: Ptr CInt
  -> Ptr (Ptr CInt)
  -> Ptr (Ptr (Ptr CInt))
  -> IO([[(Int, Int)]])
peekArrayArrayPairs  = peekArrayArray $ flatToPairs . map fromIntegral

checkErrorCodeAndThrow :: String -> Ptr CInt -> IO()
checkErrorCodeAndThrow funname errptr = do
  errcode <- peekInt errptr
  if errcode == 0
      then return ()
      else error $ funname ++ " returned nonzero error code: " ++ show errcode

gmshInitialize :: [String] -> Bool -> IO()
gmshInitialize argv readConfigFiles = do
   let argc' = fromIntegral $ length argv
   withArgv argv $ \argv' -> do
      let readConfigFiles' = fromBool readConfigFiles
      alloca $ \errptr -> do
         cgmshInitialize argc' argv' readConfigFiles' errptr
         checkErrorCodeAndThrow "gmshInitialize" errptr
         return ()
foreign import ccall safe "gmshc.h gmshInitialize"
   cgmshInitialize
      :: CInt
      -> Ptr CString
      -> CBool
      -> Ptr CInt
      -> IO()
gmshFinalize :: IO()
gmshFinalize = do
   alloca $ \errptr -> do
      cgmshFinalize errptr
      checkErrorCodeAndThrow "gmshFinalize" errptr
      return ()
foreign import ccall safe "gmshc.h gmshFinalize"
   cgmshFinalize
      :: Ptr CInt
      -> IO()
gmshOpen :: String -> IO()
gmshOpen fileName = do
   withCString fileName $ \fileName' -> do
      alloca $ \errptr -> do
         cgmshOpen fileName' errptr
         checkErrorCodeAndThrow "gmshOpen" errptr
         return ()
foreign import ccall safe "gmshc.h gmshOpen"
   cgmshOpen
      :: CString
      -> Ptr CInt
      -> IO()
gmshMerge :: String -> IO()
gmshMerge fileName = do
   withCString fileName $ \fileName' -> do
      alloca $ \errptr -> do
         cgmshMerge fileName' errptr
         checkErrorCodeAndThrow "gmshMerge" errptr
         return ()
foreign import ccall safe "gmshc.h gmshMerge"
   cgmshMerge
      :: CString
      -> Ptr CInt
      -> IO()
gmshWrite :: String -> IO()
gmshWrite fileName = do
   withCString fileName $ \fileName' -> do
      alloca $ \errptr -> do
         cgmshWrite fileName' errptr
         checkErrorCodeAndThrow "gmshWrite" errptr
         return ()
foreign import ccall safe "gmshc.h gmshWrite"
   cgmshWrite
      :: CString
      -> Ptr CInt
      -> IO()
gmshClear :: IO()
gmshClear = do
   alloca $ \errptr -> do
      cgmshClear errptr
      checkErrorCodeAndThrow "gmshClear" errptr
      return ()
foreign import ccall safe "gmshc.h gmshClear"
   cgmshClear
      :: Ptr CInt
      -> IO()
gmshOptionSetNumber :: String -> Double -> IO()
gmshOptionSetNumber name value = do
   withCString name $ \name' -> do
      let value' = realToFrac value
      alloca $ \errptr -> do
         cgmshOptionSetNumber name' value' errptr
         checkErrorCodeAndThrow "gmshOptionSetNumber" errptr
         return ()
foreign import ccall safe "gmshc.h gmshOptionSetNumber"
   cgmshOptionSetNumber
      :: CString
      -> CDouble
      -> Ptr CInt
      -> IO()
gmshOptionGetNumber :: String -> IO(Double)
gmshOptionGetNumber name = do
   withCString name $ \name' -> do
      alloca $ \value' -> do
         alloca $ \errptr -> do
            cgmshOptionGetNumber name' value' errptr
            checkErrorCodeAndThrow "gmshOptionGetNumber" errptr
            value'' <- peek value'
            let value''' = realToFrac value''
            return (value''')
foreign import ccall safe "gmshc.h gmshOptionGetNumber"
   cgmshOptionGetNumber
      :: CString
      -> Ptr CDouble
      -> Ptr CInt
      -> IO()
gmshOptionSetString :: String -> String -> IO()
gmshOptionSetString name value = do
   withCString name $ \name' -> do
      withCString value $ \value' -> do
         alloca $ \errptr -> do
            cgmshOptionSetString name' value' errptr
            checkErrorCodeAndThrow "gmshOptionSetString" errptr
            return ()
foreign import ccall safe "gmshc.h gmshOptionSetString"
   cgmshOptionSetString
      :: CString
      -> CString
      -> Ptr CInt
      -> IO()
gmshOptionGetString :: String -> IO(String)
gmshOptionGetString name = do
   withCString name $ \name' -> do
      alloca $ \value' -> do
         alloca $ \errptr -> do
            cgmshOptionGetString name' value' errptr
            checkErrorCodeAndThrow "gmshOptionGetString" errptr
            value'' <- peek value'
            value''' <- peekCString value''
            return (value''')
foreign import ccall safe "gmshc.h gmshOptionGetString"
   cgmshOptionGetString
      :: CString
      -> Ptr CString
      -> Ptr CInt
      -> IO()
gmshOptionSetColor :: String -> Int -> Int -> Int -> Int -> IO()
gmshOptionSetColor name r g b a = do
   withCString name $ \name' -> do
      let r' = fromIntegral r
      let g' = fromIntegral g
      let b' = fromIntegral b
      let a' = fromIntegral a
      alloca $ \errptr -> do
         cgmshOptionSetColor name' r' g' b' a' errptr
         checkErrorCodeAndThrow "gmshOptionSetColor" errptr
         return ()
foreign import ccall safe "gmshc.h gmshOptionSetColor"
   cgmshOptionSetColor
      :: CString
      -> CInt
      -> CInt
      -> CInt
      -> CInt
      -> Ptr CInt
      -> IO()
gmshOptionGetColor :: String -> IO(Int, Int, Int, Int)
gmshOptionGetColor name = do
   withCString name $ \name' -> do
      alloca $ \r' -> do
         alloca $ \g' -> do
            alloca $ \b' -> do
               alloca $ \a' -> do
                  alloca $ \errptr -> do
                     cgmshOptionGetColor name' r' g' b' a' errptr
                     checkErrorCodeAndThrow "gmshOptionGetColor" errptr
                     r'' <- peek r'
                     let r''' = fromIntegral r''
                     g'' <- peek g'
                     let g''' = fromIntegral g''
                     b'' <- peek b'
                     let b''' = fromIntegral b''
                     a'' <- peek a'
                     let a''' = fromIntegral a''
                     return (r''', g''', b''', a''')
foreign import ccall safe "gmshc.h gmshOptionGetColor"
   cgmshOptionGetColor
      :: CString
      -> Ptr CInt
      -> Ptr CInt
      -> Ptr CInt
      -> Ptr CInt
      -> Ptr CInt
      -> IO()
gmshModelAdd :: String -> IO()
gmshModelAdd name = do
   withCString name $ \name' -> do
      alloca $ \errptr -> do
         cgmshModelAdd name' errptr
         checkErrorCodeAndThrow "gmshModelAdd" errptr
         return ()
foreign import ccall safe "gmshc.h gmshModelAdd"
   cgmshModelAdd
      :: CString
      -> Ptr CInt
      -> IO()
gmshModelRemove :: IO()
gmshModelRemove = do
   alloca $ \errptr -> do
      cgmshModelRemove errptr
      checkErrorCodeAndThrow "gmshModelRemove" errptr
      return ()
foreign import ccall safe "gmshc.h gmshModelRemove"
   cgmshModelRemove
      :: Ptr CInt
      -> IO()
gmshModelList :: IO([String])
gmshModelList = do
   alloca $ \names' -> do
      alloca $ \names_n' -> do
         alloca $ \errptr -> do
            cgmshModelList names' names_n' errptr
            checkErrorCodeAndThrow "gmshModelList" errptr
            names'' <- peekArrayString names_n' names'
            return (names'')
foreign import ccall safe "gmshc.h gmshModelList"
   cgmshModelList
      :: Ptr ( Ptr CString)
      -> Ptr CInt
      -> Ptr CInt
      -> IO()
gmshModelSetCurrent :: String -> IO()
gmshModelSetCurrent name = do
   withCString name $ \name' -> do
      alloca $ \errptr -> do
         cgmshModelSetCurrent name' errptr
         checkErrorCodeAndThrow "gmshModelSetCurrent" errptr
         return ()
foreign import ccall safe "gmshc.h gmshModelSetCurrent"
   cgmshModelSetCurrent
      :: CString
      -> Ptr CInt
      -> IO()
gmshModelGetEntities :: Int -> IO([(Int,Int)])
gmshModelGetEntities dim = do
   let dim' = fromIntegral dim
   alloca $ \dimTags' -> do
      alloca $ \dimTags_n' -> do
         alloca $ \errptr -> do
            cgmshModelGetEntities dimTags' dimTags_n' dim' errptr
            checkErrorCodeAndThrow "gmshModelGetEntities" errptr
            dimTags'' <- peekArrayPairs dimTags_n' dimTags'
            return (dimTags'')
foreign import ccall safe "gmshc.h gmshModelGetEntities"
   cgmshModelGetEntities
      :: Ptr ( Ptr CInt)
      -> Ptr CInt
      -> CInt
      -> Ptr CInt
      -> IO()
gmshModelSetEntityName :: Int -> Int -> String -> IO()
gmshModelSetEntityName dim tag name = do
   let dim' = fromIntegral dim
   let tag' = fromIntegral tag
   withCString name $ \name' -> do
      alloca $ \errptr -> do
         cgmshModelSetEntityName dim' tag' name' errptr
         checkErrorCodeAndThrow "gmshModelSetEntityName" errptr
         return ()
foreign import ccall safe "gmshc.h gmshModelSetEntityName"
   cgmshModelSetEntityName
      :: CInt
      -> CInt
      -> CString
      -> Ptr CInt
      -> IO()
gmshModelGetEntityName :: Int -> Int -> IO(String)
gmshModelGetEntityName dim tag = do
   let dim' = fromIntegral dim
   let tag' = fromIntegral tag
   alloca $ \name' -> do
      alloca $ \errptr -> do
         cgmshModelGetEntityName dim' tag' name' errptr
         checkErrorCodeAndThrow "gmshModelGetEntityName" errptr
         name'' <- peek name'
         name''' <- peekCString name''
         return (name''')
foreign import ccall safe "gmshc.h gmshModelGetEntityName"
   cgmshModelGetEntityName
      :: CInt
      -> CInt
      -> Ptr CString
      -> Ptr CInt
      -> IO()
gmshModelGetPhysicalGroups :: Int -> IO([(Int,Int)])
gmshModelGetPhysicalGroups dim = do
   let dim' = fromIntegral dim
   alloca $ \dimTags' -> do
      alloca $ \dimTags_n' -> do
         alloca $ \errptr -> do
            cgmshModelGetPhysicalGroups dimTags' dimTags_n' dim' errptr
            checkErrorCodeAndThrow "gmshModelGetPhysicalGroups" errptr
            dimTags'' <- peekArrayPairs dimTags_n' dimTags'
            return (dimTags'')
foreign import ccall safe "gmshc.h gmshModelGetPhysicalGroups"
   cgmshModelGetPhysicalGroups
      :: Ptr ( Ptr CInt)
      -> Ptr CInt
      -> CInt
      -> Ptr CInt
      -> IO()
gmshModelGetEntitiesForPhysicalGroup :: Int -> Int -> IO([Int])
gmshModelGetEntitiesForPhysicalGroup dim tag = do
   let dim' = fromIntegral dim
   let tag' = fromIntegral tag
   alloca $ \tags' -> do
      alloca $ \tags_n' -> do
         alloca $ \errptr -> do
            cgmshModelGetEntitiesForPhysicalGroup dim' tag' tags' tags_n' errptr
            checkErrorCodeAndThrow "gmshModelGetEntitiesForPhysicalGroup" errptr
            tags'' <- peekArrayInt tags_n' tags'
            return (tags'')
foreign import ccall safe "gmshc.h gmshModelGetEntitiesForPhysicalGroup"
   cgmshModelGetEntitiesForPhysicalGroup
      :: CInt
      -> CInt
      -> Ptr ( Ptr CInt)
      -> Ptr CInt
      -> Ptr CInt
      -> IO()
gmshModelGetPhysicalGroupsForEntity :: Int -> Int -> IO([Int])
gmshModelGetPhysicalGroupsForEntity dim tag = do
   let dim' = fromIntegral dim
   let tag' = fromIntegral tag
   alloca $ \physicalTags' -> do
      alloca $ \physicalTags_n' -> do
         alloca $ \errptr -> do
            cgmshModelGetPhysicalGroupsForEntity dim' tag' physicalTags' physicalTags_n' errptr
            checkErrorCodeAndThrow "gmshModelGetPhysicalGroupsForEntity" errptr
            physicalTags'' <- peekArrayInt physicalTags_n' physicalTags'
            return (physicalTags'')
foreign import ccall safe "gmshc.h gmshModelGetPhysicalGroupsForEntity"
   cgmshModelGetPhysicalGroupsForEntity
      :: CInt
      -> CInt
      -> Ptr ( Ptr CInt)
      -> Ptr CInt
      -> Ptr CInt
      -> IO()
gmshModelAddPhysicalGroup :: Int -> [Int] -> Int -> IO(Int)
gmshModelAddPhysicalGroup dim tags tag = do
   let dim' = fromIntegral dim
   withArrayIntLen tags $ \tags_n' tags' -> do
      let tag' = fromIntegral tag
      alloca $ \errptr -> do
         oval'' <- cgmshModelAddPhysicalGroup dim' tags' tags_n' tag' errptr
         checkErrorCodeAndThrow "gmshModelAddPhysicalGroup" errptr
         let oval''' = fromIntegral oval''
         return (oval''')
foreign import ccall safe "gmshc.h gmshModelAddPhysicalGroup"
   cgmshModelAddPhysicalGroup
      :: CInt
      -> Ptr CInt
      -> CInt
      -> CInt
      -> Ptr CInt
      -> IO(CInt)
gmshModelSetPhysicalName :: Int -> Int -> String -> IO()
gmshModelSetPhysicalName dim tag name = do
   let dim' = fromIntegral dim
   let tag' = fromIntegral tag
   withCString name $ \name' -> do
      alloca $ \errptr -> do
         cgmshModelSetPhysicalName dim' tag' name' errptr
         checkErrorCodeAndThrow "gmshModelSetPhysicalName" errptr
         return ()
foreign import ccall safe "gmshc.h gmshModelSetPhysicalName"
   cgmshModelSetPhysicalName
      :: CInt
      -> CInt
      -> CString
      -> Ptr CInt
      -> IO()
gmshModelGetPhysicalName :: Int -> Int -> IO(String)
gmshModelGetPhysicalName dim tag = do
   let dim' = fromIntegral dim
   let tag' = fromIntegral tag
   alloca $ \name' -> do
      alloca $ \errptr -> do
         cgmshModelGetPhysicalName dim' tag' name' errptr
         checkErrorCodeAndThrow "gmshModelGetPhysicalName" errptr
         name'' <- peek name'
         name''' <- peekCString name''
         return (name''')
foreign import ccall safe "gmshc.h gmshModelGetPhysicalName"
   cgmshModelGetPhysicalName
      :: CInt
      -> CInt
      -> Ptr CString
      -> Ptr CInt
      -> IO()
gmshModelGetBoundary :: [(Int, Int)] -> Bool -> Bool -> Bool -> IO([(Int,Int)])
gmshModelGetBoundary dimTags combined oriented recursive = do
   withArrayPairLen dimTags $ \dimTags_n' dimTags' -> do
      let combined' = fromBool combined
      let oriented' = fromBool oriented
      let recursive' = fromBool recursive
      alloca $ \outDimTags' -> do
         alloca $ \outDimTags_n' -> do
            alloca $ \errptr -> do
               cgmshModelGetBoundary dimTags' dimTags_n' outDimTags' outDimTags_n' combined' oriented' recursive' errptr
               checkErrorCodeAndThrow "gmshModelGetBoundary" errptr
               outDimTags'' <- peekArrayPairs outDimTags_n' outDimTags'
               return (outDimTags'')
foreign import ccall safe "gmshc.h gmshModelGetBoundary"
   cgmshModelGetBoundary
      :: Ptr CInt
      -> CInt
      -> Ptr ( Ptr CInt)
      -> Ptr CInt
      -> CBool
      -> CBool
      -> CBool
      -> Ptr CInt
      -> IO()
gmshModelGetEntitiesInBoundingBox :: Double -> Double -> Double -> Double -> Double -> Double -> Int -> IO([(Int,Int)])
gmshModelGetEntitiesInBoundingBox xmin ymin zmin xmax ymax zmax dim = do
   let xmin' = realToFrac xmin
   let ymin' = realToFrac ymin
   let zmin' = realToFrac zmin
   let xmax' = realToFrac xmax
   let ymax' = realToFrac ymax
   let zmax' = realToFrac zmax
   let dim' = fromIntegral dim
   alloca $ \tags' -> do
      alloca $ \tags_n' -> do
         alloca $ \errptr -> do
            cgmshModelGetEntitiesInBoundingBox xmin' ymin' zmin' xmax' ymax' zmax' tags' tags_n' dim' errptr
            checkErrorCodeAndThrow "gmshModelGetEntitiesInBoundingBox" errptr
            tags'' <- peekArrayPairs tags_n' tags'
            return (tags'')
foreign import ccall safe "gmshc.h gmshModelGetEntitiesInBoundingBox"
   cgmshModelGetEntitiesInBoundingBox
      :: CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> Ptr ( Ptr CInt)
      -> Ptr CInt
      -> CInt
      -> Ptr CInt
      -> IO()
gmshModelGetBoundingBox :: Int -> Int -> IO(Double, Double, Double, Double, Double, Double)
gmshModelGetBoundingBox dim tag = do
   let dim' = fromIntegral dim
   let tag' = fromIntegral tag
   alloca $ \xmin' -> do
      alloca $ \ymin' -> do
         alloca $ \zmin' -> do
            alloca $ \xmax' -> do
               alloca $ \ymax' -> do
                  alloca $ \zmax' -> do
                     alloca $ \errptr -> do
                        cgmshModelGetBoundingBox dim' tag' xmin' ymin' zmin' xmax' ymax' zmax' errptr
                        checkErrorCodeAndThrow "gmshModelGetBoundingBox" errptr
                        xmin'' <- peek xmin'
                        let xmin''' = realToFrac xmin''
                        ymin'' <- peek ymin'
                        let ymin''' = realToFrac ymin''
                        zmin'' <- peek zmin'
                        let zmin''' = realToFrac zmin''
                        xmax'' <- peek xmax'
                        let xmax''' = realToFrac xmax''
                        ymax'' <- peek ymax'
                        let ymax''' = realToFrac ymax''
                        zmax'' <- peek zmax'
                        let zmax''' = realToFrac zmax''
                        return (xmin''', ymin''', zmin''', xmax''', ymax''', zmax''')
foreign import ccall safe "gmshc.h gmshModelGetBoundingBox"
   cgmshModelGetBoundingBox
      :: CInt
      -> CInt
      -> Ptr CDouble
      -> Ptr CDouble
      -> Ptr CDouble
      -> Ptr CDouble
      -> Ptr CDouble
      -> Ptr CDouble
      -> Ptr CInt
      -> IO()
gmshModelGetDimension :: IO(Int)
gmshModelGetDimension = do
   alloca $ \errptr -> do
      oval'' <- cgmshModelGetDimension errptr
      checkErrorCodeAndThrow "gmshModelGetDimension" errptr
      let oval''' = fromIntegral oval''
      return (oval''')
foreign import ccall safe "gmshc.h gmshModelGetDimension"
   cgmshModelGetDimension
      :: Ptr CInt
      -> IO(CInt)
gmshModelAddDiscreteEntity :: Int -> Int -> [Int] -> IO(Int)
gmshModelAddDiscreteEntity dim tag boundary = do
   let dim' = fromIntegral dim
   let tag' = fromIntegral tag
   withArrayIntLen boundary $ \boundary_n' boundary' -> do
      alloca $ \errptr -> do
         oval'' <- cgmshModelAddDiscreteEntity dim' tag' boundary' boundary_n' errptr
         checkErrorCodeAndThrow "gmshModelAddDiscreteEntity" errptr
         let oval''' = fromIntegral oval''
         return (oval''')
foreign import ccall safe "gmshc.h gmshModelAddDiscreteEntity"
   cgmshModelAddDiscreteEntity
      :: CInt
      -> CInt
      -> Ptr CInt
      -> CInt
      -> Ptr CInt
      -> IO(CInt)
gmshModelRemoveEntities :: [(Int, Int)] -> Bool -> IO()
gmshModelRemoveEntities dimTags recursive = do
   withArrayPairLen dimTags $ \dimTags_n' dimTags' -> do
      let recursive' = fromBool recursive
      alloca $ \errptr -> do
         cgmshModelRemoveEntities dimTags' dimTags_n' recursive' errptr
         checkErrorCodeAndThrow "gmshModelRemoveEntities" errptr
         return ()
foreign import ccall safe "gmshc.h gmshModelRemoveEntities"
   cgmshModelRemoveEntities
      :: Ptr CInt
      -> CInt
      -> CBool
      -> Ptr CInt
      -> IO()
gmshModelRemoveEntityName :: String -> IO()
gmshModelRemoveEntityName name = do
   withCString name $ \name' -> do
      alloca $ \errptr -> do
         cgmshModelRemoveEntityName name' errptr
         checkErrorCodeAndThrow "gmshModelRemoveEntityName" errptr
         return ()
foreign import ccall safe "gmshc.h gmshModelRemoveEntityName"
   cgmshModelRemoveEntityName
      :: CString
      -> Ptr CInt
      -> IO()
gmshModelRemovePhysicalGroups :: [(Int, Int)] -> IO()
gmshModelRemovePhysicalGroups dimTags = do
   withArrayPairLen dimTags $ \dimTags_n' dimTags' -> do
      alloca $ \errptr -> do
         cgmshModelRemovePhysicalGroups dimTags' dimTags_n' errptr
         checkErrorCodeAndThrow "gmshModelRemovePhysicalGroups" errptr
         return ()
foreign import ccall safe "gmshc.h gmshModelRemovePhysicalGroups"
   cgmshModelRemovePhysicalGroups
      :: Ptr CInt
      -> CInt
      -> Ptr CInt
      -> IO()
gmshModelRemovePhysicalName :: String -> IO()
gmshModelRemovePhysicalName name = do
   withCString name $ \name' -> do
      alloca $ \errptr -> do
         cgmshModelRemovePhysicalName name' errptr
         checkErrorCodeAndThrow "gmshModelRemovePhysicalName" errptr
         return ()
foreign import ccall safe "gmshc.h gmshModelRemovePhysicalName"
   cgmshModelRemovePhysicalName
      :: CString
      -> Ptr CInt
      -> IO()
gmshModelGetType :: Int -> Int -> IO(String)
gmshModelGetType dim tag = do
   let dim' = fromIntegral dim
   let tag' = fromIntegral tag
   alloca $ \entityType' -> do
      alloca $ \errptr -> do
         cgmshModelGetType dim' tag' entityType' errptr
         checkErrorCodeAndThrow "gmshModelGetType" errptr
         entityType'' <- peek entityType'
         entityType''' <- peekCString entityType''
         return (entityType''')
foreign import ccall safe "gmshc.h gmshModelGetType"
   cgmshModelGetType
      :: CInt
      -> CInt
      -> Ptr CString
      -> Ptr CInt
      -> IO()
gmshModelGetParent :: Int -> Int -> IO(Int, Int)
gmshModelGetParent dim tag = do
   let dim' = fromIntegral dim
   let tag' = fromIntegral tag
   alloca $ \parentDim' -> do
      alloca $ \parentTag' -> do
         alloca $ \errptr -> do
            cgmshModelGetParent dim' tag' parentDim' parentTag' errptr
            checkErrorCodeAndThrow "gmshModelGetParent" errptr
            parentDim'' <- peek parentDim'
            let parentDim''' = fromIntegral parentDim''
            parentTag'' <- peek parentTag'
            let parentTag''' = fromIntegral parentTag''
            return (parentDim''', parentTag''')
foreign import ccall safe "gmshc.h gmshModelGetParent"
   cgmshModelGetParent
      :: CInt
      -> CInt
      -> Ptr CInt
      -> Ptr CInt
      -> Ptr CInt
      -> IO()
gmshModelGetPartitions :: Int -> Int -> IO([Int])
gmshModelGetPartitions dim tag = do
   let dim' = fromIntegral dim
   let tag' = fromIntegral tag
   alloca $ \partitions' -> do
      alloca $ \partitions_n' -> do
         alloca $ \errptr -> do
            cgmshModelGetPartitions dim' tag' partitions' partitions_n' errptr
            checkErrorCodeAndThrow "gmshModelGetPartitions" errptr
            partitions'' <- peekArrayInt partitions_n' partitions'
            return (partitions'')
foreign import ccall safe "gmshc.h gmshModelGetPartitions"
   cgmshModelGetPartitions
      :: CInt
      -> CInt
      -> Ptr ( Ptr CInt)
      -> Ptr CInt
      -> Ptr CInt
      -> IO()
gmshModelGetValue :: Int -> Int -> [Double] -> IO([Double])
gmshModelGetValue dim tag parametricCoord = do
   let dim' = fromIntegral dim
   let tag' = fromIntegral tag
   withArrayDoubleLen parametricCoord $ \parametricCoord_n' parametricCoord' -> do
      alloca $ \points' -> do
         alloca $ \points_n' -> do
            alloca $ \errptr -> do
               cgmshModelGetValue dim' tag' parametricCoord' parametricCoord_n' points' points_n' errptr
               checkErrorCodeAndThrow "gmshModelGetValue" errptr
               points'' <- peekArrayDouble points_n' points'
               return (points'')
foreign import ccall safe "gmshc.h gmshModelGetValue"
   cgmshModelGetValue
      :: CInt
      -> CInt
      -> Ptr CDouble
      -> CInt
      -> Ptr ( Ptr CDouble)
      -> Ptr CInt
      -> Ptr CInt
      -> IO()
gmshModelGetDerivative :: Int -> Int -> [Double] -> IO([Double])
gmshModelGetDerivative dim tag parametricCoord = do
   let dim' = fromIntegral dim
   let tag' = fromIntegral tag
   withArrayDoubleLen parametricCoord $ \parametricCoord_n' parametricCoord' -> do
      alloca $ \derivatives' -> do
         alloca $ \derivatives_n' -> do
            alloca $ \errptr -> do
               cgmshModelGetDerivative dim' tag' parametricCoord' parametricCoord_n' derivatives' derivatives_n' errptr
               checkErrorCodeAndThrow "gmshModelGetDerivative" errptr
               derivatives'' <- peekArrayDouble derivatives_n' derivatives'
               return (derivatives'')
foreign import ccall safe "gmshc.h gmshModelGetDerivative"
   cgmshModelGetDerivative
      :: CInt
      -> CInt
      -> Ptr CDouble
      -> CInt
      -> Ptr ( Ptr CDouble)
      -> Ptr CInt
      -> Ptr CInt
      -> IO()
gmshModelGetCurvature :: Int -> Int -> [Double] -> IO([Double])
gmshModelGetCurvature dim tag parametricCoord = do
   let dim' = fromIntegral dim
   let tag' = fromIntegral tag
   withArrayDoubleLen parametricCoord $ \parametricCoord_n' parametricCoord' -> do
      alloca $ \curvatures' -> do
         alloca $ \curvatures_n' -> do
            alloca $ \errptr -> do
               cgmshModelGetCurvature dim' tag' parametricCoord' parametricCoord_n' curvatures' curvatures_n' errptr
               checkErrorCodeAndThrow "gmshModelGetCurvature" errptr
               curvatures'' <- peekArrayDouble curvatures_n' curvatures'
               return (curvatures'')
foreign import ccall safe "gmshc.h gmshModelGetCurvature"
   cgmshModelGetCurvature
      :: CInt
      -> CInt
      -> Ptr CDouble
      -> CInt
      -> Ptr ( Ptr CDouble)
      -> Ptr CInt
      -> Ptr CInt
      -> IO()
gmshModelGetPrincipalCurvatures :: Int -> [Double] -> IO([Double], [Double], [Double], [Double])
gmshModelGetPrincipalCurvatures tag parametricCoord = do
   let tag' = fromIntegral tag
   withArrayDoubleLen parametricCoord $ \parametricCoord_n' parametricCoord' -> do
      alloca $ \curvatureMax' -> do
         alloca $ \curvatureMax_n' -> do
            alloca $ \curvatureMin' -> do
               alloca $ \curvatureMin_n' -> do
                  alloca $ \directionMax' -> do
                     alloca $ \directionMax_n' -> do
                        alloca $ \directionMin' -> do
                           alloca $ \directionMin_n' -> do
                              alloca $ \errptr -> do
                                 cgmshModelGetPrincipalCurvatures tag' parametricCoord' parametricCoord_n' curvatureMax' curvatureMax_n' curvatureMin' curvatureMin_n' directionMax' directionMax_n' directionMin' directionMin_n' errptr
                                 checkErrorCodeAndThrow "gmshModelGetPrincipalCurvatures" errptr
                                 curvatureMax'' <- peekArrayDouble curvatureMax_n' curvatureMax'
                                 curvatureMin'' <- peekArrayDouble curvatureMin_n' curvatureMin'
                                 directionMax'' <- peekArrayDouble directionMax_n' directionMax'
                                 directionMin'' <- peekArrayDouble directionMin_n' directionMin'
                                 return (curvatureMax'', curvatureMin'', directionMax'', directionMin'')
foreign import ccall safe "gmshc.h gmshModelGetPrincipalCurvatures"
   cgmshModelGetPrincipalCurvatures
      :: CInt
      -> Ptr CDouble
      -> CInt
      -> Ptr ( Ptr CDouble)
      -> Ptr CInt
      -> Ptr ( Ptr CDouble)
      -> Ptr CInt
      -> Ptr ( Ptr CDouble)
      -> Ptr CInt
      -> Ptr ( Ptr CDouble)
      -> Ptr CInt
      -> Ptr CInt
      -> IO()
gmshModelGetNormal :: Int -> [Double] -> IO([Double])
gmshModelGetNormal tag parametricCoord = do
   let tag' = fromIntegral tag
   withArrayDoubleLen parametricCoord $ \parametricCoord_n' parametricCoord' -> do
      alloca $ \normals' -> do
         alloca $ \normals_n' -> do
            alloca $ \errptr -> do
               cgmshModelGetNormal tag' parametricCoord' parametricCoord_n' normals' normals_n' errptr
               checkErrorCodeAndThrow "gmshModelGetNormal" errptr
               normals'' <- peekArrayDouble normals_n' normals'
               return (normals'')
foreign import ccall safe "gmshc.h gmshModelGetNormal"
   cgmshModelGetNormal
      :: CInt
      -> Ptr CDouble
      -> CInt
      -> Ptr ( Ptr CDouble)
      -> Ptr CInt
      -> Ptr CInt
      -> IO()
gmshModelSetVisibility :: [(Int, Int)] -> Int -> Bool -> IO()
gmshModelSetVisibility dimTags value recursive = do
   withArrayPairLen dimTags $ \dimTags_n' dimTags' -> do
      let value' = fromIntegral value
      let recursive' = fromBool recursive
      alloca $ \errptr -> do
         cgmshModelSetVisibility dimTags' dimTags_n' value' recursive' errptr
         checkErrorCodeAndThrow "gmshModelSetVisibility" errptr
         return ()
foreign import ccall safe "gmshc.h gmshModelSetVisibility"
   cgmshModelSetVisibility
      :: Ptr CInt
      -> CInt
      -> CInt
      -> CBool
      -> Ptr CInt
      -> IO()
gmshModelGetVisibility :: Int -> Int -> IO(Int)
gmshModelGetVisibility dim tag = do
   let dim' = fromIntegral dim
   let tag' = fromIntegral tag
   alloca $ \value' -> do
      alloca $ \errptr -> do
         cgmshModelGetVisibility dim' tag' value' errptr
         checkErrorCodeAndThrow "gmshModelGetVisibility" errptr
         value'' <- peek value'
         let value''' = fromIntegral value''
         return (value''')
foreign import ccall safe "gmshc.h gmshModelGetVisibility"
   cgmshModelGetVisibility
      :: CInt
      -> CInt
      -> Ptr CInt
      -> Ptr CInt
      -> IO()
gmshModelSetColor :: [(Int, Int)] -> Int -> Int -> Int -> Int -> Bool -> IO()
gmshModelSetColor dimTags r g b a recursive = do
   withArrayPairLen dimTags $ \dimTags_n' dimTags' -> do
      let r' = fromIntegral r
      let g' = fromIntegral g
      let b' = fromIntegral b
      let a' = fromIntegral a
      let recursive' = fromBool recursive
      alloca $ \errptr -> do
         cgmshModelSetColor dimTags' dimTags_n' r' g' b' a' recursive' errptr
         checkErrorCodeAndThrow "gmshModelSetColor" errptr
         return ()
foreign import ccall safe "gmshc.h gmshModelSetColor"
   cgmshModelSetColor
      :: Ptr CInt
      -> CInt
      -> CInt
      -> CInt
      -> CInt
      -> CInt
      -> CBool
      -> Ptr CInt
      -> IO()
gmshModelGetColor :: Int -> Int -> IO(Int, Int, Int, Int)
gmshModelGetColor dim tag = do
   let dim' = fromIntegral dim
   let tag' = fromIntegral tag
   alloca $ \r' -> do
      alloca $ \g' -> do
         alloca $ \b' -> do
            alloca $ \a' -> do
               alloca $ \errptr -> do
                  cgmshModelGetColor dim' tag' r' g' b' a' errptr
                  checkErrorCodeAndThrow "gmshModelGetColor" errptr
                  r'' <- peek r'
                  let r''' = fromIntegral r''
                  g'' <- peek g'
                  let g''' = fromIntegral g''
                  b'' <- peek b'
                  let b''' = fromIntegral b''
                  a'' <- peek a'
                  let a''' = fromIntegral a''
                  return (r''', g''', b''', a''')
foreign import ccall safe "gmshc.h gmshModelGetColor"
   cgmshModelGetColor
      :: CInt
      -> CInt
      -> Ptr CInt
      -> Ptr CInt
      -> Ptr CInt
      -> Ptr CInt
      -> Ptr CInt
      -> IO()
gmshModelSetCoordinates :: Int -> Double -> Double -> Double -> IO()
gmshModelSetCoordinates tag x y z = do
   let tag' = fromIntegral tag
   let x' = realToFrac x
   let y' = realToFrac y
   let z' = realToFrac z
   alloca $ \errptr -> do
      cgmshModelSetCoordinates tag' x' y' z' errptr
      checkErrorCodeAndThrow "gmshModelSetCoordinates" errptr
      return ()
foreign import ccall safe "gmshc.h gmshModelSetCoordinates"
   cgmshModelSetCoordinates
      :: CInt
      -> CDouble
      -> CDouble
      -> CDouble
      -> Ptr CInt
      -> IO()
gmshModelMeshGenerate :: Int -> IO()
gmshModelMeshGenerate dim = do
   let dim' = fromIntegral dim
   alloca $ \errptr -> do
      cgmshModelMeshGenerate dim' errptr
      checkErrorCodeAndThrow "gmshModelMeshGenerate" errptr
      return ()
foreign import ccall safe "gmshc.h gmshModelMeshGenerate"
   cgmshModelMeshGenerate
      :: CInt
      -> Ptr CInt
      -> IO()
gmshModelMeshPartition :: Int -> IO()
gmshModelMeshPartition numPart = do
   let numPart' = fromIntegral numPart
   alloca $ \errptr -> do
      cgmshModelMeshPartition numPart' errptr
      checkErrorCodeAndThrow "gmshModelMeshPartition" errptr
      return ()
foreign import ccall safe "gmshc.h gmshModelMeshPartition"
   cgmshModelMeshPartition
      :: CInt
      -> Ptr CInt
      -> IO()
gmshModelMeshUnpartition :: IO()
gmshModelMeshUnpartition = do
   alloca $ \errptr -> do
      cgmshModelMeshUnpartition errptr
      checkErrorCodeAndThrow "gmshModelMeshUnpartition" errptr
      return ()
foreign import ccall safe "gmshc.h gmshModelMeshUnpartition"
   cgmshModelMeshUnpartition
      :: Ptr CInt
      -> IO()
gmshModelMeshOptimize :: String -> Bool -> IO()
gmshModelMeshOptimize method force = do
   withCString method $ \method' -> do
      let force' = fromBool force
      alloca $ \errptr -> do
         cgmshModelMeshOptimize method' force' errptr
         checkErrorCodeAndThrow "gmshModelMeshOptimize" errptr
         return ()
foreign import ccall safe "gmshc.h gmshModelMeshOptimize"
   cgmshModelMeshOptimize
      :: CString
      -> CBool
      -> Ptr CInt
      -> IO()
gmshModelMeshRecombine :: IO()
gmshModelMeshRecombine = do
   alloca $ \errptr -> do
      cgmshModelMeshRecombine errptr
      checkErrorCodeAndThrow "gmshModelMeshRecombine" errptr
      return ()
foreign import ccall safe "gmshc.h gmshModelMeshRecombine"
   cgmshModelMeshRecombine
      :: Ptr CInt
      -> IO()
gmshModelMeshRefine :: IO()
gmshModelMeshRefine = do
   alloca $ \errptr -> do
      cgmshModelMeshRefine errptr
      checkErrorCodeAndThrow "gmshModelMeshRefine" errptr
      return ()
foreign import ccall safe "gmshc.h gmshModelMeshRefine"
   cgmshModelMeshRefine
      :: Ptr CInt
      -> IO()
gmshModelMeshSmooth :: IO()
gmshModelMeshSmooth = do
   alloca $ \errptr -> do
      cgmshModelMeshSmooth errptr
      checkErrorCodeAndThrow "gmshModelMeshSmooth" errptr
      return ()
foreign import ccall safe "gmshc.h gmshModelMeshSmooth"
   cgmshModelMeshSmooth
      :: Ptr CInt
      -> IO()
gmshModelMeshSetOrder :: Int -> IO()
gmshModelMeshSetOrder order = do
   let order' = fromIntegral order
   alloca $ \errptr -> do
      cgmshModelMeshSetOrder order' errptr
      checkErrorCodeAndThrow "gmshModelMeshSetOrder" errptr
      return ()
foreign import ccall safe "gmshc.h gmshModelMeshSetOrder"
   cgmshModelMeshSetOrder
      :: CInt
      -> Ptr CInt
      -> IO()
gmshModelMeshGetLastEntityError :: IO([(Int,Int)])
gmshModelMeshGetLastEntityError = do
   alloca $ \dimTags' -> do
      alloca $ \dimTags_n' -> do
         alloca $ \errptr -> do
            cgmshModelMeshGetLastEntityError dimTags' dimTags_n' errptr
            checkErrorCodeAndThrow "gmshModelMeshGetLastEntityError" errptr
            dimTags'' <- peekArrayPairs dimTags_n' dimTags'
            return (dimTags'')
foreign import ccall safe "gmshc.h gmshModelMeshGetLastEntityError"
   cgmshModelMeshGetLastEntityError
      :: Ptr ( Ptr CInt)
      -> Ptr CInt
      -> Ptr CInt
      -> IO()
gmshModelMeshGetLastNodeError :: IO([Int])
gmshModelMeshGetLastNodeError = do
   alloca $ \nodeTags' -> do
      alloca $ \nodeTags_n' -> do
         alloca $ \errptr -> do
            cgmshModelMeshGetLastNodeError nodeTags' nodeTags_n' errptr
            checkErrorCodeAndThrow "gmshModelMeshGetLastNodeError" errptr
            nodeTags'' <- peekArrayInt nodeTags_n' nodeTags'
            return (nodeTags'')
foreign import ccall safe "gmshc.h gmshModelMeshGetLastNodeError"
   cgmshModelMeshGetLastNodeError
      :: Ptr ( Ptr CInt)
      -> Ptr CInt
      -> Ptr CInt
      -> IO()
gmshModelMeshClear :: IO()
gmshModelMeshClear = do
   alloca $ \errptr -> do
      cgmshModelMeshClear errptr
      checkErrorCodeAndThrow "gmshModelMeshClear" errptr
      return ()
foreign import ccall safe "gmshc.h gmshModelMeshClear"
   cgmshModelMeshClear
      :: Ptr CInt
      -> IO()
gmshModelMeshGetNodes :: Int -> Int -> Bool -> Bool -> IO([Int], [Double], [Double])
gmshModelMeshGetNodes dim tag includeBoundary returnParametricCoord = do
   let dim' = fromIntegral dim
   let tag' = fromIntegral tag
   let includeBoundary' = fromBool includeBoundary
   let returnParametricCoord' = fromBool returnParametricCoord
   alloca $ \nodeTags' -> do
      alloca $ \nodeTags_n' -> do
         alloca $ \coord' -> do
            alloca $ \coord_n' -> do
               alloca $ \parametricCoord' -> do
                  alloca $ \parametricCoord_n' -> do
                     alloca $ \errptr -> do
                        cgmshModelMeshGetNodes nodeTags' nodeTags_n' coord' coord_n' parametricCoord' parametricCoord_n' dim' tag' includeBoundary' returnParametricCoord' errptr
                        checkErrorCodeAndThrow "gmshModelMeshGetNodes" errptr
                        nodeTags'' <- peekArrayInt nodeTags_n' nodeTags'
                        coord'' <- peekArrayDouble coord_n' coord'
                        parametricCoord'' <- peekArrayDouble parametricCoord_n' parametricCoord'
                        return (nodeTags'', coord'', parametricCoord'')
foreign import ccall safe "gmshc.h gmshModelMeshGetNodes"
   cgmshModelMeshGetNodes
      :: Ptr ( Ptr CInt)
      -> Ptr CInt
      -> Ptr ( Ptr CDouble)
      -> Ptr CInt
      -> Ptr ( Ptr CDouble)
      -> Ptr CInt
      -> CInt
      -> CInt
      -> CBool
      -> CBool
      -> Ptr CInt
      -> IO()
gmshModelMeshGetNodesByElementType :: Int -> Int -> Bool -> IO([Int], [Double], [Double])
gmshModelMeshGetNodesByElementType elementType tag returnParametricCoord = do
   let elementType' = fromIntegral elementType
   let tag' = fromIntegral tag
   let returnParametricCoord' = fromBool returnParametricCoord
   alloca $ \nodeTags' -> do
      alloca $ \nodeTags_n' -> do
         alloca $ \coord' -> do
            alloca $ \coord_n' -> do
               alloca $ \parametricCoord' -> do
                  alloca $ \parametricCoord_n' -> do
                     alloca $ \errptr -> do
                        cgmshModelMeshGetNodesByElementType elementType' nodeTags' nodeTags_n' coord' coord_n' parametricCoord' parametricCoord_n' tag' returnParametricCoord' errptr
                        checkErrorCodeAndThrow "gmshModelMeshGetNodesByElementType" errptr
                        nodeTags'' <- peekArrayInt nodeTags_n' nodeTags'
                        coord'' <- peekArrayDouble coord_n' coord'
                        parametricCoord'' <- peekArrayDouble parametricCoord_n' parametricCoord'
                        return (nodeTags'', coord'', parametricCoord'')
foreign import ccall safe "gmshc.h gmshModelMeshGetNodesByElementType"
   cgmshModelMeshGetNodesByElementType
      :: CInt
      -> Ptr ( Ptr CInt)
      -> Ptr CInt
      -> Ptr ( Ptr CDouble)
      -> Ptr CInt
      -> Ptr ( Ptr CDouble)
      -> Ptr CInt
      -> CInt
      -> CBool
      -> Ptr CInt
      -> IO()
gmshModelMeshGetNode :: Int -> IO([Double], [Double])
gmshModelMeshGetNode nodeTag = do
   let nodeTag' = fromIntegral nodeTag
   alloca $ \coord' -> do
      alloca $ \coord_n' -> do
         alloca $ \parametricCoord' -> do
            alloca $ \parametricCoord_n' -> do
               alloca $ \errptr -> do
                  cgmshModelMeshGetNode nodeTag' coord' coord_n' parametricCoord' parametricCoord_n' errptr
                  checkErrorCodeAndThrow "gmshModelMeshGetNode" errptr
                  coord'' <- peekArrayDouble coord_n' coord'
                  parametricCoord'' <- peekArrayDouble parametricCoord_n' parametricCoord'
                  return (coord'', parametricCoord'')
foreign import ccall safe "gmshc.h gmshModelMeshGetNode"
   cgmshModelMeshGetNode
      :: CInt
      -> Ptr ( Ptr CDouble)
      -> Ptr CInt
      -> Ptr ( Ptr CDouble)
      -> Ptr CInt
      -> Ptr CInt
      -> IO()
gmshModelMeshRebuildNodeCache :: Bool -> IO()
gmshModelMeshRebuildNodeCache onlyIfNecessary = do
   let onlyIfNecessary' = fromBool onlyIfNecessary
   alloca $ \errptr -> do
      cgmshModelMeshRebuildNodeCache onlyIfNecessary' errptr
      checkErrorCodeAndThrow "gmshModelMeshRebuildNodeCache" errptr
      return ()
foreign import ccall safe "gmshc.h gmshModelMeshRebuildNodeCache"
   cgmshModelMeshRebuildNodeCache
      :: CBool
      -> Ptr CInt
      -> IO()
gmshModelMeshGetNodesForPhysicalGroup :: Int -> Int -> IO([Int], [Double])
gmshModelMeshGetNodesForPhysicalGroup dim tag = do
   let dim' = fromIntegral dim
   let tag' = fromIntegral tag
   alloca $ \nodeTags' -> do
      alloca $ \nodeTags_n' -> do
         alloca $ \coord' -> do
            alloca $ \coord_n' -> do
               alloca $ \errptr -> do
                  cgmshModelMeshGetNodesForPhysicalGroup dim' tag' nodeTags' nodeTags_n' coord' coord_n' errptr
                  checkErrorCodeAndThrow "gmshModelMeshGetNodesForPhysicalGroup" errptr
                  nodeTags'' <- peekArrayInt nodeTags_n' nodeTags'
                  coord'' <- peekArrayDouble coord_n' coord'
                  return (nodeTags'', coord'')
foreign import ccall safe "gmshc.h gmshModelMeshGetNodesForPhysicalGroup"
   cgmshModelMeshGetNodesForPhysicalGroup
      :: CInt
      -> CInt
      -> Ptr ( Ptr CInt)
      -> Ptr CInt
      -> Ptr ( Ptr CDouble)
      -> Ptr CInt
      -> Ptr CInt
      -> IO()
gmshModelMeshAddNodes :: Int -> Int -> [Int] -> [Double] -> [Double] -> IO()
gmshModelMeshAddNodes dim tag nodeTags coord parametricCoord = do
   let dim' = fromIntegral dim
   let tag' = fromIntegral tag
   withArrayIntLen nodeTags $ \nodeTags_n' nodeTags' -> do
      withArrayDoubleLen coord $ \coord_n' coord' -> do
         withArrayDoubleLen parametricCoord $ \parametricCoord_n' parametricCoord' -> do
            alloca $ \errptr -> do
               cgmshModelMeshAddNodes dim' tag' nodeTags' nodeTags_n' coord' coord_n' parametricCoord' parametricCoord_n' errptr
               checkErrorCodeAndThrow "gmshModelMeshAddNodes" errptr
               return ()
foreign import ccall safe "gmshc.h gmshModelMeshAddNodes"
   cgmshModelMeshAddNodes
      :: CInt
      -> CInt
      -> Ptr CInt
      -> CInt
      -> Ptr CDouble
      -> CInt
      -> Ptr CDouble
      -> CInt
      -> Ptr CInt
      -> IO()
gmshModelMeshReclassifyNodes :: IO()
gmshModelMeshReclassifyNodes = do
   alloca $ \errptr -> do
      cgmshModelMeshReclassifyNodes errptr
      checkErrorCodeAndThrow "gmshModelMeshReclassifyNodes" errptr
      return ()
foreign import ccall safe "gmshc.h gmshModelMeshReclassifyNodes"
   cgmshModelMeshReclassifyNodes
      :: Ptr CInt
      -> IO()
gmshModelMeshRelocateNodes :: Int -> Int -> IO()
gmshModelMeshRelocateNodes dim tag = do
   let dim' = fromIntegral dim
   let tag' = fromIntegral tag
   alloca $ \errptr -> do
      cgmshModelMeshRelocateNodes dim' tag' errptr
      checkErrorCodeAndThrow "gmshModelMeshRelocateNodes" errptr
      return ()
foreign import ccall safe "gmshc.h gmshModelMeshRelocateNodes"
   cgmshModelMeshRelocateNodes
      :: CInt
      -> CInt
      -> Ptr CInt
      -> IO()
gmshModelMeshGetElements :: Int -> Int -> IO([Int], [[Int]], [[Int]])
gmshModelMeshGetElements dim tag = do
   let dim' = fromIntegral dim
   let tag' = fromIntegral tag
   alloca $ \elementTypes' -> do
      alloca $ \elementTypes_n' -> do
         alloca $ \elementTags' -> do
            alloca $ \elementTags_n' -> do
               alloca $ \elementTags_nn' -> do
                  alloca $ \nodeTags' -> do
                     alloca $ \nodeTags_n' -> do
                        alloca $ \nodeTags_nn' -> do
                           alloca $ \errptr -> do
                              cgmshModelMeshGetElements elementTypes' elementTypes_n' elementTags' elementTags_n' elementTags_nn' nodeTags' nodeTags_n' nodeTags_nn' dim' tag' errptr
                              checkErrorCodeAndThrow "gmshModelMeshGetElements" errptr
                              elementTypes'' <- peekArrayInt elementTypes_n' elementTypes'
                              elementTags'' <- peekArrayArrayInt elementTags_nn' elementTags_n' elementTags'
                              nodeTags'' <- peekArrayArrayInt nodeTags_nn' nodeTags_n' nodeTags'
                              return (elementTypes'', elementTags'', nodeTags'')
foreign import ccall safe "gmshc.h gmshModelMeshGetElements"
   cgmshModelMeshGetElements
      :: Ptr ( Ptr CInt)
      -> Ptr CInt
      -> Ptr (Ptr (Ptr CInt))
      -> Ptr (Ptr CInt)
      -> Ptr CInt
      -> Ptr (Ptr (Ptr CInt))
      -> Ptr (Ptr CInt)
      -> Ptr CInt
      -> CInt
      -> CInt
      -> Ptr CInt
      -> IO()
gmshModelMeshGetElement :: Int -> IO(Int, [Int])
gmshModelMeshGetElement elementTag = do
   let elementTag' = fromIntegral elementTag
   alloca $ \elementType' -> do
      alloca $ \nodeTags' -> do
         alloca $ \nodeTags_n' -> do
            alloca $ \errptr -> do
               cgmshModelMeshGetElement elementTag' elementType' nodeTags' nodeTags_n' errptr
               checkErrorCodeAndThrow "gmshModelMeshGetElement" errptr
               elementType'' <- peek elementType'
               let elementType''' = fromIntegral elementType''
               nodeTags'' <- peekArrayInt nodeTags_n' nodeTags'
               return (elementType''', nodeTags'')
foreign import ccall safe "gmshc.h gmshModelMeshGetElement"
   cgmshModelMeshGetElement
      :: CInt
      -> Ptr CInt
      -> Ptr ( Ptr CInt)
      -> Ptr CInt
      -> Ptr CInt
      -> IO()
gmshModelMeshGetElementByCoordinates :: Double -> Double -> Double -> Int -> Bool -> IO(Int, Int, [Int], Double, Double, Double)
gmshModelMeshGetElementByCoordinates x y z dim strict = do
   let x' = realToFrac x
   let y' = realToFrac y
   let z' = realToFrac z
   let dim' = fromIntegral dim
   let strict' = fromBool strict
   alloca $ \elementTag' -> do
      alloca $ \elementType' -> do
         alloca $ \nodeTags' -> do
            alloca $ \nodeTags_n' -> do
               alloca $ \u' -> do
                  alloca $ \v' -> do
                     alloca $ \w' -> do
                        alloca $ \errptr -> do
                           cgmshModelMeshGetElementByCoordinates x' y' z' elementTag' elementType' nodeTags' nodeTags_n' u' v' w' dim' strict' errptr
                           checkErrorCodeAndThrow "gmshModelMeshGetElementByCoordinates" errptr
                           elementTag'' <- peek elementTag'
                           let elementTag''' = fromIntegral elementTag''
                           elementType'' <- peek elementType'
                           let elementType''' = fromIntegral elementType''
                           nodeTags'' <- peekArrayInt nodeTags_n' nodeTags'
                           u'' <- peek u'
                           let u''' = realToFrac u''
                           v'' <- peek v'
                           let v''' = realToFrac v''
                           w'' <- peek w'
                           let w''' = realToFrac w''
                           return (elementTag''', elementType''', nodeTags'', u''', v''', w''')
foreign import ccall safe "gmshc.h gmshModelMeshGetElementByCoordinates"
   cgmshModelMeshGetElementByCoordinates
      :: CDouble
      -> CDouble
      -> CDouble
      -> Ptr CInt
      -> Ptr CInt
      -> Ptr ( Ptr CInt)
      -> Ptr CInt
      -> Ptr CDouble
      -> Ptr CDouble
      -> Ptr CDouble
      -> CInt
      -> CBool
      -> Ptr CInt
      -> IO()
gmshModelMeshGetElementTypes :: Int -> Int -> IO([Int])
gmshModelMeshGetElementTypes dim tag = do
   let dim' = fromIntegral dim
   let tag' = fromIntegral tag
   alloca $ \elementTypes' -> do
      alloca $ \elementTypes_n' -> do
         alloca $ \errptr -> do
            cgmshModelMeshGetElementTypes elementTypes' elementTypes_n' dim' tag' errptr
            checkErrorCodeAndThrow "gmshModelMeshGetElementTypes" errptr
            elementTypes'' <- peekArrayInt elementTypes_n' elementTypes'
            return (elementTypes'')
foreign import ccall safe "gmshc.h gmshModelMeshGetElementTypes"
   cgmshModelMeshGetElementTypes
      :: Ptr ( Ptr CInt)
      -> Ptr CInt
      -> CInt
      -> CInt
      -> Ptr CInt
      -> IO()
gmshModelMeshGetElementType :: String -> Int -> Bool -> IO(Int)
gmshModelMeshGetElementType familyName order serendip = do
   withCString familyName $ \familyName' -> do
      let order' = fromIntegral order
      let serendip' = fromBool serendip
      alloca $ \errptr -> do
         oval'' <- cgmshModelMeshGetElementType familyName' order' serendip' errptr
         checkErrorCodeAndThrow "gmshModelMeshGetElementType" errptr
         let oval''' = fromIntegral oval''
         return (oval''')
foreign import ccall safe "gmshc.h gmshModelMeshGetElementType"
   cgmshModelMeshGetElementType
      :: CString
      -> CInt
      -> CBool
      -> Ptr CInt
      -> IO(CInt)
gmshModelMeshGetElementProperties :: Int -> IO(String, Int, Int, Int, [Double])
gmshModelMeshGetElementProperties elementType = do
   let elementType' = fromIntegral elementType
   alloca $ \elementName' -> do
      alloca $ \dim' -> do
         alloca $ \order' -> do
            alloca $ \numNodes' -> do
               alloca $ \nodeCoord' -> do
                  alloca $ \nodeCoord_n' -> do
                     alloca $ \errptr -> do
                        cgmshModelMeshGetElementProperties elementType' elementName' dim' order' numNodes' nodeCoord' nodeCoord_n' errptr
                        checkErrorCodeAndThrow "gmshModelMeshGetElementProperties" errptr
                        elementName'' <- peek elementName'
                        elementName''' <- peekCString elementName''
                        dim'' <- peek dim'
                        let dim''' = fromIntegral dim''
                        order'' <- peek order'
                        let order''' = fromIntegral order''
                        numNodes'' <- peek numNodes'
                        let numNodes''' = fromIntegral numNodes''
                        nodeCoord'' <- peekArrayDouble nodeCoord_n' nodeCoord'
                        return (elementName''', dim''', order''', numNodes''', nodeCoord'')
foreign import ccall safe "gmshc.h gmshModelMeshGetElementProperties"
   cgmshModelMeshGetElementProperties
      :: CInt
      -> Ptr CString
      -> Ptr CInt
      -> Ptr CInt
      -> Ptr CInt
      -> Ptr ( Ptr CDouble)
      -> Ptr CInt
      -> Ptr CInt
      -> IO()
gmshModelMeshGetElementsByType :: Int -> Int -> Int -> Int -> IO([Int], [Int])
gmshModelMeshGetElementsByType elementType tag task numTasks = do
   let elementType' = fromIntegral elementType
   let tag' = fromIntegral tag
   let task' = fromIntegral task
   let numTasks' = fromIntegral numTasks
   alloca $ \elementTags' -> do
      alloca $ \elementTags_n' -> do
         alloca $ \nodeTags' -> do
            alloca $ \nodeTags_n' -> do
               alloca $ \errptr -> do
                  cgmshModelMeshGetElementsByType elementType' elementTags' elementTags_n' nodeTags' nodeTags_n' tag' task' numTasks' errptr
                  checkErrorCodeAndThrow "gmshModelMeshGetElementsByType" errptr
                  elementTags'' <- peekArrayInt elementTags_n' elementTags'
                  nodeTags'' <- peekArrayInt nodeTags_n' nodeTags'
                  return (elementTags'', nodeTags'')
foreign import ccall safe "gmshc.h gmshModelMeshGetElementsByType"
   cgmshModelMeshGetElementsByType
      :: CInt
      -> Ptr ( Ptr CInt)
      -> Ptr CInt
      -> Ptr ( Ptr CInt)
      -> Ptr CInt
      -> CInt
      -> CInt
      -> CInt
      -> Ptr CInt
      -> IO()
gmshModelMeshAddElements :: Int -> Int -> [Int] -> [[Int]] -> [[Int]] -> IO()
gmshModelMeshAddElements dim tag elementTypes elementTags nodeTags = do
   let dim' = fromIntegral dim
   let tag' = fromIntegral tag
   withArrayIntLen elementTypes $ \elementTypes_n' elementTypes' -> do
      withArrayArrayIntLen elementTags $ \elementTags_nn' elementTags_n' elementTags' -> do
            withArrayArrayIntLen nodeTags $ \nodeTags_nn' nodeTags_n' nodeTags' -> do
                  alloca $ \errptr -> do
                     cgmshModelMeshAddElements dim' tag' elementTypes' elementTypes_n' elementTags' elementTags_n' elementTags_nn' nodeTags' nodeTags_n' nodeTags_nn' errptr
                     checkErrorCodeAndThrow "gmshModelMeshAddElements" errptr
                     return ()
foreign import ccall safe "gmshc.h gmshModelMeshAddElements"
   cgmshModelMeshAddElements
      :: CInt
      -> CInt
      -> Ptr CInt
      -> CInt
      -> Ptr (Ptr CInt)
      -> Ptr CInt
      -> CInt
      -> Ptr (Ptr CInt)
      -> Ptr CInt
      -> CInt
      -> Ptr CInt
      -> IO()
gmshModelMeshAddElementsByType :: Int -> Int -> [Int] -> [Int] -> IO()
gmshModelMeshAddElementsByType tag elementType elementTags nodeTags = do
   let tag' = fromIntegral tag
   let elementType' = fromIntegral elementType
   withArrayIntLen elementTags $ \elementTags_n' elementTags' -> do
      withArrayIntLen nodeTags $ \nodeTags_n' nodeTags' -> do
         alloca $ \errptr -> do
            cgmshModelMeshAddElementsByType tag' elementType' elementTags' elementTags_n' nodeTags' nodeTags_n' errptr
            checkErrorCodeAndThrow "gmshModelMeshAddElementsByType" errptr
            return ()
foreign import ccall safe "gmshc.h gmshModelMeshAddElementsByType"
   cgmshModelMeshAddElementsByType
      :: CInt
      -> CInt
      -> Ptr CInt
      -> CInt
      -> Ptr CInt
      -> CInt
      -> Ptr CInt
      -> IO()
gmshModelMeshGetIntegrationPoints :: Int -> String -> IO([Double], [Double])
gmshModelMeshGetIntegrationPoints elementType integrationType = do
   let elementType' = fromIntegral elementType
   withCString integrationType $ \integrationType' -> do
      alloca $ \integrationPoints' -> do
         alloca $ \integrationPoints_n' -> do
            alloca $ \integrationWeights' -> do
               alloca $ \integrationWeights_n' -> do
                  alloca $ \errptr -> do
                     cgmshModelMeshGetIntegrationPoints elementType' integrationType' integrationPoints' integrationPoints_n' integrationWeights' integrationWeights_n' errptr
                     checkErrorCodeAndThrow "gmshModelMeshGetIntegrationPoints" errptr
                     integrationPoints'' <- peekArrayDouble integrationPoints_n' integrationPoints'
                     integrationWeights'' <- peekArrayDouble integrationWeights_n' integrationWeights'
                     return (integrationPoints'', integrationWeights'')
foreign import ccall safe "gmshc.h gmshModelMeshGetIntegrationPoints"
   cgmshModelMeshGetIntegrationPoints
      :: CInt
      -> CString
      -> Ptr ( Ptr CDouble)
      -> Ptr CInt
      -> Ptr ( Ptr CDouble)
      -> Ptr CInt
      -> Ptr CInt
      -> IO()
gmshModelMeshGetJacobians :: Int -> [Double] -> Int -> Int -> Int -> IO([Double], [Double], [Double])
gmshModelMeshGetJacobians elementType integrationPoints tag task numTasks = do
   let elementType' = fromIntegral elementType
   withArrayDoubleLen integrationPoints $ \integrationPoints_n' integrationPoints' -> do
      let tag' = fromIntegral tag
      let task' = fromIntegral task
      let numTasks' = fromIntegral numTasks
      alloca $ \jacobians' -> do
         alloca $ \jacobians_n' -> do
            alloca $ \determinants' -> do
               alloca $ \determinants_n' -> do
                  alloca $ \points' -> do
                     alloca $ \points_n' -> do
                        alloca $ \errptr -> do
                           cgmshModelMeshGetJacobians elementType' integrationPoints' integrationPoints_n' jacobians' jacobians_n' determinants' determinants_n' points' points_n' tag' task' numTasks' errptr
                           checkErrorCodeAndThrow "gmshModelMeshGetJacobians" errptr
                           jacobians'' <- peekArrayDouble jacobians_n' jacobians'
                           determinants'' <- peekArrayDouble determinants_n' determinants'
                           points'' <- peekArrayDouble points_n' points'
                           return (jacobians'', determinants'', points'')
foreign import ccall safe "gmshc.h gmshModelMeshGetJacobians"
   cgmshModelMeshGetJacobians
      :: CInt
      -> Ptr CDouble
      -> CInt
      -> Ptr ( Ptr CDouble)
      -> Ptr CInt
      -> Ptr ( Ptr CDouble)
      -> Ptr CInt
      -> Ptr ( Ptr CDouble)
      -> Ptr CInt
      -> CInt
      -> CInt
      -> CInt
      -> Ptr CInt
      -> IO()
gmshModelMeshGetBasisFunctions :: Int -> [Double] -> String -> IO(Int, [Double])
gmshModelMeshGetBasisFunctions elementType integrationPoints functionSpaceType = do
   let elementType' = fromIntegral elementType
   withArrayDoubleLen integrationPoints $ \integrationPoints_n' integrationPoints' -> do
      withCString functionSpaceType $ \functionSpaceType' -> do
         alloca $ \numComponents' -> do
            alloca $ \basisFunctions' -> do
               alloca $ \basisFunctions_n' -> do
                  alloca $ \errptr -> do
                     cgmshModelMeshGetBasisFunctions elementType' integrationPoints' integrationPoints_n' functionSpaceType' numComponents' basisFunctions' basisFunctions_n' errptr
                     checkErrorCodeAndThrow "gmshModelMeshGetBasisFunctions" errptr
                     numComponents'' <- peek numComponents'
                     let numComponents''' = fromIntegral numComponents''
                     basisFunctions'' <- peekArrayDouble basisFunctions_n' basisFunctions'
                     return (numComponents''', basisFunctions'')
foreign import ccall safe "gmshc.h gmshModelMeshGetBasisFunctions"
   cgmshModelMeshGetBasisFunctions
      :: CInt
      -> Ptr CDouble
      -> CInt
      -> CString
      -> Ptr CInt
      -> Ptr ( Ptr CDouble)
      -> Ptr CInt
      -> Ptr CInt
      -> IO()
gmshModelMeshGetBasisFunctionsForElements :: Int -> [Double] -> String -> Int -> IO(Int, Int, [Double])
gmshModelMeshGetBasisFunctionsForElements elementType integrationPoints functionSpaceType tag = do
   let elementType' = fromIntegral elementType
   withArrayDoubleLen integrationPoints $ \integrationPoints_n' integrationPoints' -> do
      withCString functionSpaceType $ \functionSpaceType' -> do
         let tag' = fromIntegral tag
         alloca $ \numComponents' -> do
            alloca $ \numFunctionsPerElements' -> do
               alloca $ \basisFunctions' -> do
                  alloca $ \basisFunctions_n' -> do
                     alloca $ \errptr -> do
                        cgmshModelMeshGetBasisFunctionsForElements elementType' integrationPoints' integrationPoints_n' functionSpaceType' numComponents' numFunctionsPerElements' basisFunctions' basisFunctions_n' tag' errptr
                        checkErrorCodeAndThrow "gmshModelMeshGetBasisFunctionsForElements" errptr
                        numComponents'' <- peek numComponents'
                        let numComponents''' = fromIntegral numComponents''
                        numFunctionsPerElements'' <- peek numFunctionsPerElements'
                        let numFunctionsPerElements''' = fromIntegral numFunctionsPerElements''
                        basisFunctions'' <- peekArrayDouble basisFunctions_n' basisFunctions'
                        return (numComponents''', numFunctionsPerElements''', basisFunctions'')
foreign import ccall safe "gmshc.h gmshModelMeshGetBasisFunctionsForElements"
   cgmshModelMeshGetBasisFunctionsForElements
      :: CInt
      -> Ptr CDouble
      -> CInt
      -> CString
      -> Ptr CInt
      -> Ptr CInt
      -> Ptr ( Ptr CDouble)
      -> Ptr CInt
      -> CInt
      -> Ptr CInt
      -> IO()
gmshModelMeshGetKeysForElements :: Int -> String -> Int -> Bool -> IO([(Int,Int)], [Double])
gmshModelMeshGetKeysForElements elementType functionSpaceType tag returnCoord = do
   let elementType' = fromIntegral elementType
   withCString functionSpaceType $ \functionSpaceType' -> do
      let tag' = fromIntegral tag
      let returnCoord' = fromBool returnCoord
      alloca $ \keys' -> do
         alloca $ \keys_n' -> do
            alloca $ \coord' -> do
               alloca $ \coord_n' -> do
                  alloca $ \errptr -> do
                     cgmshModelMeshGetKeysForElements elementType' functionSpaceType' keys' keys_n' coord' coord_n' tag' returnCoord' errptr
                     checkErrorCodeAndThrow "gmshModelMeshGetKeysForElements" errptr
                     keys'' <- peekArrayPairs keys_n' keys'
                     coord'' <- peekArrayDouble coord_n' coord'
                     return (keys'', coord'')
foreign import ccall safe "gmshc.h gmshModelMeshGetKeysForElements"
   cgmshModelMeshGetKeysForElements
      :: CInt
      -> CString
      -> Ptr ( Ptr CInt)
      -> Ptr CInt
      -> Ptr ( Ptr CDouble)
      -> Ptr CInt
      -> CInt
      -> CBool
      -> Ptr CInt
      -> IO()
gmshModelMeshGetInformationForElements :: [(Int, Int)] -> Int -> String -> IO([(Int,Int)])
gmshModelMeshGetInformationForElements keys elementType functionSpaceType = do
   withArrayPairLen keys $ \keys_n' keys' -> do
      let elementType' = fromIntegral elementType
      withCString functionSpaceType $ \functionSpaceType' -> do
         alloca $ \infoKeys' -> do
            alloca $ \infoKeys_n' -> do
               alloca $ \errptr -> do
                  cgmshModelMeshGetInformationForElements keys' keys_n' elementType' functionSpaceType' infoKeys' infoKeys_n' errptr
                  checkErrorCodeAndThrow "gmshModelMeshGetInformationForElements" errptr
                  infoKeys'' <- peekArrayPairs infoKeys_n' infoKeys'
                  return (infoKeys'')
foreign import ccall safe "gmshc.h gmshModelMeshGetInformationForElements"
   cgmshModelMeshGetInformationForElements
      :: Ptr CInt
      -> CInt
      -> CInt
      -> CString
      -> Ptr ( Ptr CInt)
      -> Ptr CInt
      -> Ptr CInt
      -> IO()
gmshModelMeshPrecomputeBasisFunctions :: Int -> IO()
gmshModelMeshPrecomputeBasisFunctions elementType = do
   let elementType' = fromIntegral elementType
   alloca $ \errptr -> do
      cgmshModelMeshPrecomputeBasisFunctions elementType' errptr
      checkErrorCodeAndThrow "gmshModelMeshPrecomputeBasisFunctions" errptr
      return ()
foreign import ccall safe "gmshc.h gmshModelMeshPrecomputeBasisFunctions"
   cgmshModelMeshPrecomputeBasisFunctions
      :: CInt
      -> Ptr CInt
      -> IO()
gmshModelMeshGetBarycenters :: Int -> Int -> Bool -> Bool -> Int -> Int -> IO([Double])
gmshModelMeshGetBarycenters elementType tag fast primary task numTasks = do
   let elementType' = fromIntegral elementType
   let tag' = fromIntegral tag
   let fast' = fromBool fast
   let primary' = fromBool primary
   let task' = fromIntegral task
   let numTasks' = fromIntegral numTasks
   alloca $ \barycenters' -> do
      alloca $ \barycenters_n' -> do
         alloca $ \errptr -> do
            cgmshModelMeshGetBarycenters elementType' tag' fast' primary' barycenters' barycenters_n' task' numTasks' errptr
            checkErrorCodeAndThrow "gmshModelMeshGetBarycenters" errptr
            barycenters'' <- peekArrayDouble barycenters_n' barycenters'
            return (barycenters'')
foreign import ccall safe "gmshc.h gmshModelMeshGetBarycenters"
   cgmshModelMeshGetBarycenters
      :: CInt
      -> CInt
      -> CBool
      -> CBool
      -> Ptr ( Ptr CDouble)
      -> Ptr CInt
      -> CInt
      -> CInt
      -> Ptr CInt
      -> IO()
gmshModelMeshGetElementEdgeNodes :: Int -> Int -> Bool -> Int -> Int -> IO([Int])
gmshModelMeshGetElementEdgeNodes elementType tag primary task numTasks = do
   let elementType' = fromIntegral elementType
   let tag' = fromIntegral tag
   let primary' = fromBool primary
   let task' = fromIntegral task
   let numTasks' = fromIntegral numTasks
   alloca $ \nodeTags' -> do
      alloca $ \nodeTags_n' -> do
         alloca $ \errptr -> do
            cgmshModelMeshGetElementEdgeNodes elementType' nodeTags' nodeTags_n' tag' primary' task' numTasks' errptr
            checkErrorCodeAndThrow "gmshModelMeshGetElementEdgeNodes" errptr
            nodeTags'' <- peekArrayInt nodeTags_n' nodeTags'
            return (nodeTags'')
foreign import ccall safe "gmshc.h gmshModelMeshGetElementEdgeNodes"
   cgmshModelMeshGetElementEdgeNodes
      :: CInt
      -> Ptr ( Ptr CInt)
      -> Ptr CInt
      -> CInt
      -> CBool
      -> CInt
      -> CInt
      -> Ptr CInt
      -> IO()
gmshModelMeshGetElementFaceNodes :: Int -> Int -> Int -> Bool -> Int -> Int -> IO([Int])
gmshModelMeshGetElementFaceNodes elementType faceType tag primary task numTasks = do
   let elementType' = fromIntegral elementType
   let faceType' = fromIntegral faceType
   let tag' = fromIntegral tag
   let primary' = fromBool primary
   let task' = fromIntegral task
   let numTasks' = fromIntegral numTasks
   alloca $ \nodeTags' -> do
      alloca $ \nodeTags_n' -> do
         alloca $ \errptr -> do
            cgmshModelMeshGetElementFaceNodes elementType' faceType' nodeTags' nodeTags_n' tag' primary' task' numTasks' errptr
            checkErrorCodeAndThrow "gmshModelMeshGetElementFaceNodes" errptr
            nodeTags'' <- peekArrayInt nodeTags_n' nodeTags'
            return (nodeTags'')
foreign import ccall safe "gmshc.h gmshModelMeshGetElementFaceNodes"
   cgmshModelMeshGetElementFaceNodes
      :: CInt
      -> CInt
      -> Ptr ( Ptr CInt)
      -> Ptr CInt
      -> CInt
      -> CBool
      -> CInt
      -> CInt
      -> Ptr CInt
      -> IO()
gmshModelMeshGetGhostElements :: Int -> Int -> IO([Int], [Int])
gmshModelMeshGetGhostElements dim tag = do
   let dim' = fromIntegral dim
   let tag' = fromIntegral tag
   alloca $ \elementTags' -> do
      alloca $ \elementTags_n' -> do
         alloca $ \partitions' -> do
            alloca $ \partitions_n' -> do
               alloca $ \errptr -> do
                  cgmshModelMeshGetGhostElements dim' tag' elementTags' elementTags_n' partitions' partitions_n' errptr
                  checkErrorCodeAndThrow "gmshModelMeshGetGhostElements" errptr
                  elementTags'' <- peekArrayInt elementTags_n' elementTags'
                  partitions'' <- peekArrayInt partitions_n' partitions'
                  return (elementTags'', partitions'')
foreign import ccall safe "gmshc.h gmshModelMeshGetGhostElements"
   cgmshModelMeshGetGhostElements
      :: CInt
      -> CInt
      -> Ptr ( Ptr CInt)
      -> Ptr CInt
      -> Ptr ( Ptr CInt)
      -> Ptr CInt
      -> Ptr CInt
      -> IO()
gmshModelMeshSetSize :: [(Int, Int)] -> Double -> IO()
gmshModelMeshSetSize dimTags size = do
   withArrayPairLen dimTags $ \dimTags_n' dimTags' -> do
      let size' = realToFrac size
      alloca $ \errptr -> do
         cgmshModelMeshSetSize dimTags' dimTags_n' size' errptr
         checkErrorCodeAndThrow "gmshModelMeshSetSize" errptr
         return ()
foreign import ccall safe "gmshc.h gmshModelMeshSetSize"
   cgmshModelMeshSetSize
      :: Ptr CInt
      -> CInt
      -> CDouble
      -> Ptr CInt
      -> IO()
gmshModelMeshSetTransfiniteCurve :: Int -> Int -> String -> Double -> IO()
gmshModelMeshSetTransfiniteCurve tag numNodes meshType coef = do
   let tag' = fromIntegral tag
   let numNodes' = fromIntegral numNodes
   withCString meshType $ \meshType' -> do
      let coef' = realToFrac coef
      alloca $ \errptr -> do
         cgmshModelMeshSetTransfiniteCurve tag' numNodes' meshType' coef' errptr
         checkErrorCodeAndThrow "gmshModelMeshSetTransfiniteCurve" errptr
         return ()
foreign import ccall safe "gmshc.h gmshModelMeshSetTransfiniteCurve"
   cgmshModelMeshSetTransfiniteCurve
      :: CInt
      -> CInt
      -> CString
      -> CDouble
      -> Ptr CInt
      -> IO()
gmshModelMeshSetTransfiniteSurface :: Int -> String -> [Int] -> IO()
gmshModelMeshSetTransfiniteSurface tag arrangement cornerTags = do
   let tag' = fromIntegral tag
   withCString arrangement $ \arrangement' -> do
      withArrayIntLen cornerTags $ \cornerTags_n' cornerTags' -> do
         alloca $ \errptr -> do
            cgmshModelMeshSetTransfiniteSurface tag' arrangement' cornerTags' cornerTags_n' errptr
            checkErrorCodeAndThrow "gmshModelMeshSetTransfiniteSurface" errptr
            return ()
foreign import ccall safe "gmshc.h gmshModelMeshSetTransfiniteSurface"
   cgmshModelMeshSetTransfiniteSurface
      :: CInt
      -> CString
      -> Ptr CInt
      -> CInt
      -> Ptr CInt
      -> IO()
gmshModelMeshSetTransfiniteVolume :: Int -> [Int] -> IO()
gmshModelMeshSetTransfiniteVolume tag cornerTags = do
   let tag' = fromIntegral tag
   withArrayIntLen cornerTags $ \cornerTags_n' cornerTags' -> do
      alloca $ \errptr -> do
         cgmshModelMeshSetTransfiniteVolume tag' cornerTags' cornerTags_n' errptr
         checkErrorCodeAndThrow "gmshModelMeshSetTransfiniteVolume" errptr
         return ()
foreign import ccall safe "gmshc.h gmshModelMeshSetTransfiniteVolume"
   cgmshModelMeshSetTransfiniteVolume
      :: CInt
      -> Ptr CInt
      -> CInt
      -> Ptr CInt
      -> IO()
gmshModelMeshSetRecombine :: Int -> Int -> IO()
gmshModelMeshSetRecombine dim tag = do
   let dim' = fromIntegral dim
   let tag' = fromIntegral tag
   alloca $ \errptr -> do
      cgmshModelMeshSetRecombine dim' tag' errptr
      checkErrorCodeAndThrow "gmshModelMeshSetRecombine" errptr
      return ()
foreign import ccall safe "gmshc.h gmshModelMeshSetRecombine"
   cgmshModelMeshSetRecombine
      :: CInt
      -> CInt
      -> Ptr CInt
      -> IO()
gmshModelMeshSetSmoothing :: Int -> Int -> Int -> IO()
gmshModelMeshSetSmoothing dim tag val = do
   let dim' = fromIntegral dim
   let tag' = fromIntegral tag
   let val' = fromIntegral val
   alloca $ \errptr -> do
      cgmshModelMeshSetSmoothing dim' tag' val' errptr
      checkErrorCodeAndThrow "gmshModelMeshSetSmoothing" errptr
      return ()
foreign import ccall safe "gmshc.h gmshModelMeshSetSmoothing"
   cgmshModelMeshSetSmoothing
      :: CInt
      -> CInt
      -> CInt
      -> Ptr CInt
      -> IO()
gmshModelMeshSetReverse :: Int -> Int -> Bool -> IO()
gmshModelMeshSetReverse dim tag val = do
   let dim' = fromIntegral dim
   let tag' = fromIntegral tag
   let val' = fromBool val
   alloca $ \errptr -> do
      cgmshModelMeshSetReverse dim' tag' val' errptr
      checkErrorCodeAndThrow "gmshModelMeshSetReverse" errptr
      return ()
foreign import ccall safe "gmshc.h gmshModelMeshSetReverse"
   cgmshModelMeshSetReverse
      :: CInt
      -> CInt
      -> CBool
      -> Ptr CInt
      -> IO()
gmshModelMeshSetOutwardOrientation :: Int -> IO()
gmshModelMeshSetOutwardOrientation tag = do
   let tag' = fromIntegral tag
   alloca $ \errptr -> do
      cgmshModelMeshSetOutwardOrientation tag' errptr
      checkErrorCodeAndThrow "gmshModelMeshSetOutwardOrientation" errptr
      return ()
foreign import ccall safe "gmshc.h gmshModelMeshSetOutwardOrientation"
   cgmshModelMeshSetOutwardOrientation
      :: CInt
      -> Ptr CInt
      -> IO()
gmshModelMeshEmbed :: Int -> [Int] -> Int -> Int -> IO()
gmshModelMeshEmbed dim tags inDim inTag = do
   let dim' = fromIntegral dim
   withArrayIntLen tags $ \tags_n' tags' -> do
      let inDim' = fromIntegral inDim
      let inTag' = fromIntegral inTag
      alloca $ \errptr -> do
         cgmshModelMeshEmbed dim' tags' tags_n' inDim' inTag' errptr
         checkErrorCodeAndThrow "gmshModelMeshEmbed" errptr
         return ()
foreign import ccall safe "gmshc.h gmshModelMeshEmbed"
   cgmshModelMeshEmbed
      :: CInt
      -> Ptr CInt
      -> CInt
      -> CInt
      -> CInt
      -> Ptr CInt
      -> IO()
gmshModelMeshRemoveEmbedded :: [(Int, Int)] -> Int -> IO()
gmshModelMeshRemoveEmbedded dimTags dim = do
   withArrayPairLen dimTags $ \dimTags_n' dimTags' -> do
      let dim' = fromIntegral dim
      alloca $ \errptr -> do
         cgmshModelMeshRemoveEmbedded dimTags' dimTags_n' dim' errptr
         checkErrorCodeAndThrow "gmshModelMeshRemoveEmbedded" errptr
         return ()
foreign import ccall safe "gmshc.h gmshModelMeshRemoveEmbedded"
   cgmshModelMeshRemoveEmbedded
      :: Ptr CInt
      -> CInt
      -> CInt
      -> Ptr CInt
      -> IO()
gmshModelMeshReorderElements :: Int -> Int -> [Int] -> IO()
gmshModelMeshReorderElements elementType tag ordering = do
   let elementType' = fromIntegral elementType
   let tag' = fromIntegral tag
   withArrayIntLen ordering $ \ordering_n' ordering' -> do
      alloca $ \errptr -> do
         cgmshModelMeshReorderElements elementType' tag' ordering' ordering_n' errptr
         checkErrorCodeAndThrow "gmshModelMeshReorderElements" errptr
         return ()
foreign import ccall safe "gmshc.h gmshModelMeshReorderElements"
   cgmshModelMeshReorderElements
      :: CInt
      -> CInt
      -> Ptr CInt
      -> CInt
      -> Ptr CInt
      -> IO()
gmshModelMeshRenumberNodes :: IO()
gmshModelMeshRenumberNodes = do
   alloca $ \errptr -> do
      cgmshModelMeshRenumberNodes errptr
      checkErrorCodeAndThrow "gmshModelMeshRenumberNodes" errptr
      return ()
foreign import ccall safe "gmshc.h gmshModelMeshRenumberNodes"
   cgmshModelMeshRenumberNodes
      :: Ptr CInt
      -> IO()
gmshModelMeshRenumberElements :: IO()
gmshModelMeshRenumberElements = do
   alloca $ \errptr -> do
      cgmshModelMeshRenumberElements errptr
      checkErrorCodeAndThrow "gmshModelMeshRenumberElements" errptr
      return ()
foreign import ccall safe "gmshc.h gmshModelMeshRenumberElements"
   cgmshModelMeshRenumberElements
      :: Ptr CInt
      -> IO()
gmshModelMeshSetPeriodic :: Int -> [Int] -> [Int] -> [Double] -> IO()
gmshModelMeshSetPeriodic dim tags tagsMaster affineTransform = do
   let dim' = fromIntegral dim
   withArrayIntLen tags $ \tags_n' tags' -> do
      withArrayIntLen tagsMaster $ \tagsMaster_n' tagsMaster' -> do
         withArrayDoubleLen affineTransform $ \affineTransform_n' affineTransform' -> do
            alloca $ \errptr -> do
               cgmshModelMeshSetPeriodic dim' tags' tags_n' tagsMaster' tagsMaster_n' affineTransform' affineTransform_n' errptr
               checkErrorCodeAndThrow "gmshModelMeshSetPeriodic" errptr
               return ()
foreign import ccall safe "gmshc.h gmshModelMeshSetPeriodic"
   cgmshModelMeshSetPeriodic
      :: CInt
      -> Ptr CInt
      -> CInt
      -> Ptr CInt
      -> CInt
      -> Ptr CDouble
      -> CInt
      -> Ptr CInt
      -> IO()
gmshModelMeshGetPeriodicNodes :: Int -> Int -> IO(Int, [Int], [Int], [Double])
gmshModelMeshGetPeriodicNodes dim tag = do
   let dim' = fromIntegral dim
   let tag' = fromIntegral tag
   alloca $ \tagMaster' -> do
      alloca $ \nodeTags' -> do
         alloca $ \nodeTags_n' -> do
            alloca $ \nodeTagsMaster' -> do
               alloca $ \nodeTagsMaster_n' -> do
                  alloca $ \affineTransform' -> do
                     alloca $ \affineTransform_n' -> do
                        alloca $ \errptr -> do
                           cgmshModelMeshGetPeriodicNodes dim' tag' tagMaster' nodeTags' nodeTags_n' nodeTagsMaster' nodeTagsMaster_n' affineTransform' affineTransform_n' errptr
                           checkErrorCodeAndThrow "gmshModelMeshGetPeriodicNodes" errptr
                           tagMaster'' <- peek tagMaster'
                           let tagMaster''' = fromIntegral tagMaster''
                           nodeTags'' <- peekArrayInt nodeTags_n' nodeTags'
                           nodeTagsMaster'' <- peekArrayInt nodeTagsMaster_n' nodeTagsMaster'
                           affineTransform'' <- peekArrayDouble affineTransform_n' affineTransform'
                           return (tagMaster''', nodeTags'', nodeTagsMaster'', affineTransform'')
foreign import ccall safe "gmshc.h gmshModelMeshGetPeriodicNodes"
   cgmshModelMeshGetPeriodicNodes
      :: CInt
      -> CInt
      -> Ptr CInt
      -> Ptr ( Ptr CInt)
      -> Ptr CInt
      -> Ptr ( Ptr CInt)
      -> Ptr CInt
      -> Ptr ( Ptr CDouble)
      -> Ptr CInt
      -> Ptr CInt
      -> IO()
gmshModelMeshRemoveDuplicateNodes :: IO()
gmshModelMeshRemoveDuplicateNodes = do
   alloca $ \errptr -> do
      cgmshModelMeshRemoveDuplicateNodes errptr
      checkErrorCodeAndThrow "gmshModelMeshRemoveDuplicateNodes" errptr
      return ()
foreign import ccall safe "gmshc.h gmshModelMeshRemoveDuplicateNodes"
   cgmshModelMeshRemoveDuplicateNodes
      :: Ptr CInt
      -> IO()
gmshModelMeshSplitQuadrangles :: Double -> Int -> IO()
gmshModelMeshSplitQuadrangles quality tag = do
   let quality' = realToFrac quality
   let tag' = fromIntegral tag
   alloca $ \errptr -> do
      cgmshModelMeshSplitQuadrangles quality' tag' errptr
      checkErrorCodeAndThrow "gmshModelMeshSplitQuadrangles" errptr
      return ()
foreign import ccall safe "gmshc.h gmshModelMeshSplitQuadrangles"
   cgmshModelMeshSplitQuadrangles
      :: CDouble
      -> CInt
      -> Ptr CInt
      -> IO()
gmshModelMeshClassifySurfaces :: Double -> Bool -> Bool -> IO()
gmshModelMeshClassifySurfaces angle boundary forReparametrization = do
   let angle' = realToFrac angle
   let boundary' = fromBool boundary
   let forReparametrization' = fromBool forReparametrization
   alloca $ \errptr -> do
      cgmshModelMeshClassifySurfaces angle' boundary' forReparametrization' errptr
      checkErrorCodeAndThrow "gmshModelMeshClassifySurfaces" errptr
      return ()
foreign import ccall safe "gmshc.h gmshModelMeshClassifySurfaces"
   cgmshModelMeshClassifySurfaces
      :: CDouble
      -> CBool
      -> CBool
      -> Ptr CInt
      -> IO()
gmshModelMeshCreateGeometry :: IO()
gmshModelMeshCreateGeometry = do
   alloca $ \errptr -> do
      cgmshModelMeshCreateGeometry errptr
      checkErrorCodeAndThrow "gmshModelMeshCreateGeometry" errptr
      return ()
foreign import ccall safe "gmshc.h gmshModelMeshCreateGeometry"
   cgmshModelMeshCreateGeometry
      :: Ptr CInt
      -> IO()
gmshModelMeshCreateTopology :: IO()
gmshModelMeshCreateTopology = do
   alloca $ \errptr -> do
      cgmshModelMeshCreateTopology errptr
      checkErrorCodeAndThrow "gmshModelMeshCreateTopology" errptr
      return ()
foreign import ccall safe "gmshc.h gmshModelMeshCreateTopology"
   cgmshModelMeshCreateTopology
      :: Ptr CInt
      -> IO()
gmshModelMeshComputeHomology :: [Int] -> [Int] -> [Int] -> IO()
gmshModelMeshComputeHomology domainTags subdomainTags dims = do
   withArrayIntLen domainTags $ \domainTags_n' domainTags' -> do
      withArrayIntLen subdomainTags $ \subdomainTags_n' subdomainTags' -> do
         withArrayIntLen dims $ \dims_n' dims' -> do
            alloca $ \errptr -> do
               cgmshModelMeshComputeHomology domainTags' domainTags_n' subdomainTags' subdomainTags_n' dims' dims_n' errptr
               checkErrorCodeAndThrow "gmshModelMeshComputeHomology" errptr
               return ()
foreign import ccall safe "gmshc.h gmshModelMeshComputeHomology"
   cgmshModelMeshComputeHomology
      :: Ptr CInt
      -> CInt
      -> Ptr CInt
      -> CInt
      -> Ptr CInt
      -> CInt
      -> Ptr CInt
      -> IO()
gmshModelMeshComputeCohomology :: [Int] -> [Int] -> [Int] -> IO()
gmshModelMeshComputeCohomology domainTags subdomainTags dims = do
   withArrayIntLen domainTags $ \domainTags_n' domainTags' -> do
      withArrayIntLen subdomainTags $ \subdomainTags_n' subdomainTags' -> do
         withArrayIntLen dims $ \dims_n' dims' -> do
            alloca $ \errptr -> do
               cgmshModelMeshComputeCohomology domainTags' domainTags_n' subdomainTags' subdomainTags_n' dims' dims_n' errptr
               checkErrorCodeAndThrow "gmshModelMeshComputeCohomology" errptr
               return ()
foreign import ccall safe "gmshc.h gmshModelMeshComputeCohomology"
   cgmshModelMeshComputeCohomology
      :: Ptr CInt
      -> CInt
      -> Ptr CInt
      -> CInt
      -> Ptr CInt
      -> CInt
      -> Ptr CInt
      -> IO()
gmshModelMeshFieldAdd :: String -> Int -> IO(Int)
gmshModelMeshFieldAdd fieldType tag = do
   withCString fieldType $ \fieldType' -> do
      let tag' = fromIntegral tag
      alloca $ \errptr -> do
         oval'' <- cgmshModelMeshFieldAdd fieldType' tag' errptr
         checkErrorCodeAndThrow "gmshModelMeshFieldAdd" errptr
         let oval''' = fromIntegral oval''
         return (oval''')
foreign import ccall safe "gmshc.h gmshModelMeshFieldAdd"
   cgmshModelMeshFieldAdd
      :: CString
      -> CInt
      -> Ptr CInt
      -> IO(CInt)
gmshModelMeshFieldRemove :: Int -> IO()
gmshModelMeshFieldRemove tag = do
   let tag' = fromIntegral tag
   alloca $ \errptr -> do
      cgmshModelMeshFieldRemove tag' errptr
      checkErrorCodeAndThrow "gmshModelMeshFieldRemove" errptr
      return ()
foreign import ccall safe "gmshc.h gmshModelMeshFieldRemove"
   cgmshModelMeshFieldRemove
      :: CInt
      -> Ptr CInt
      -> IO()
gmshModelMeshFieldSetNumber :: Int -> String -> Double -> IO()
gmshModelMeshFieldSetNumber tag option value = do
   let tag' = fromIntegral tag
   withCString option $ \option' -> do
      let value' = realToFrac value
      alloca $ \errptr -> do
         cgmshModelMeshFieldSetNumber tag' option' value' errptr
         checkErrorCodeAndThrow "gmshModelMeshFieldSetNumber" errptr
         return ()
foreign import ccall safe "gmshc.h gmshModelMeshFieldSetNumber"
   cgmshModelMeshFieldSetNumber
      :: CInt
      -> CString
      -> CDouble
      -> Ptr CInt
      -> IO()
gmshModelMeshFieldSetString :: Int -> String -> String -> IO()
gmshModelMeshFieldSetString tag option value = do
   let tag' = fromIntegral tag
   withCString option $ \option' -> do
      withCString value $ \value' -> do
         alloca $ \errptr -> do
            cgmshModelMeshFieldSetString tag' option' value' errptr
            checkErrorCodeAndThrow "gmshModelMeshFieldSetString" errptr
            return ()
foreign import ccall safe "gmshc.h gmshModelMeshFieldSetString"
   cgmshModelMeshFieldSetString
      :: CInt
      -> CString
      -> CString
      -> Ptr CInt
      -> IO()
gmshModelMeshFieldSetNumbers :: Int -> String -> [Double] -> IO()
gmshModelMeshFieldSetNumbers tag option value = do
   let tag' = fromIntegral tag
   withCString option $ \option' -> do
      withArrayDoubleLen value $ \value_n' value' -> do
         alloca $ \errptr -> do
            cgmshModelMeshFieldSetNumbers tag' option' value' value_n' errptr
            checkErrorCodeAndThrow "gmshModelMeshFieldSetNumbers" errptr
            return ()
foreign import ccall safe "gmshc.h gmshModelMeshFieldSetNumbers"
   cgmshModelMeshFieldSetNumbers
      :: CInt
      -> CString
      -> Ptr CDouble
      -> CInt
      -> Ptr CInt
      -> IO()
gmshModelMeshFieldSetAsBackgroundMesh :: Int -> IO()
gmshModelMeshFieldSetAsBackgroundMesh tag = do
   let tag' = fromIntegral tag
   alloca $ \errptr -> do
      cgmshModelMeshFieldSetAsBackgroundMesh tag' errptr
      checkErrorCodeAndThrow "gmshModelMeshFieldSetAsBackgroundMesh" errptr
      return ()
foreign import ccall safe "gmshc.h gmshModelMeshFieldSetAsBackgroundMesh"
   cgmshModelMeshFieldSetAsBackgroundMesh
      :: CInt
      -> Ptr CInt
      -> IO()
gmshModelMeshFieldSetAsBoundaryLayer :: Int -> IO()
gmshModelMeshFieldSetAsBoundaryLayer tag = do
   let tag' = fromIntegral tag
   alloca $ \errptr -> do
      cgmshModelMeshFieldSetAsBoundaryLayer tag' errptr
      checkErrorCodeAndThrow "gmshModelMeshFieldSetAsBoundaryLayer" errptr
      return ()
foreign import ccall safe "gmshc.h gmshModelMeshFieldSetAsBoundaryLayer"
   cgmshModelMeshFieldSetAsBoundaryLayer
      :: CInt
      -> Ptr CInt
      -> IO()
gmshModelGeoAddPoint :: Double -> Double -> Double -> Double -> Int -> IO(Int)
gmshModelGeoAddPoint x y z meshSize tag = do
   let x' = realToFrac x
   let y' = realToFrac y
   let z' = realToFrac z
   let meshSize' = realToFrac meshSize
   let tag' = fromIntegral tag
   alloca $ \errptr -> do
      oval'' <- cgmshModelGeoAddPoint x' y' z' meshSize' tag' errptr
      checkErrorCodeAndThrow "gmshModelGeoAddPoint" errptr
      let oval''' = fromIntegral oval''
      return (oval''')
foreign import ccall safe "gmshc.h gmshModelGeoAddPoint"
   cgmshModelGeoAddPoint
      :: CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CInt
      -> Ptr CInt
      -> IO(CInt)
gmshModelGeoAddLine :: Int -> Int -> Int -> IO(Int)
gmshModelGeoAddLine startTag endTag tag = do
   let startTag' = fromIntegral startTag
   let endTag' = fromIntegral endTag
   let tag' = fromIntegral tag
   alloca $ \errptr -> do
      oval'' <- cgmshModelGeoAddLine startTag' endTag' tag' errptr
      checkErrorCodeAndThrow "gmshModelGeoAddLine" errptr
      let oval''' = fromIntegral oval''
      return (oval''')
foreign import ccall safe "gmshc.h gmshModelGeoAddLine"
   cgmshModelGeoAddLine
      :: CInt
      -> CInt
      -> CInt
      -> Ptr CInt
      -> IO(CInt)
gmshModelGeoAddCircleArc :: Int -> Int -> Int -> Int -> Double -> Double -> Double -> IO(Int)
gmshModelGeoAddCircleArc startTag centerTag endTag tag nx ny nz = do
   let startTag' = fromIntegral startTag
   let centerTag' = fromIntegral centerTag
   let endTag' = fromIntegral endTag
   let tag' = fromIntegral tag
   let nx' = realToFrac nx
   let ny' = realToFrac ny
   let nz' = realToFrac nz
   alloca $ \errptr -> do
      oval'' <- cgmshModelGeoAddCircleArc startTag' centerTag' endTag' tag' nx' ny' nz' errptr
      checkErrorCodeAndThrow "gmshModelGeoAddCircleArc" errptr
      let oval''' = fromIntegral oval''
      return (oval''')
foreign import ccall safe "gmshc.h gmshModelGeoAddCircleArc"
   cgmshModelGeoAddCircleArc
      :: CInt
      -> CInt
      -> CInt
      -> CInt
      -> CDouble
      -> CDouble
      -> CDouble
      -> Ptr CInt
      -> IO(CInt)
gmshModelGeoAddEllipseArc :: Int -> Int -> Int -> Int -> Int -> Double -> Double -> Double -> IO(Int)
gmshModelGeoAddEllipseArc startTag centerTag majorTag endTag tag nx ny nz = do
   let startTag' = fromIntegral startTag
   let centerTag' = fromIntegral centerTag
   let majorTag' = fromIntegral majorTag
   let endTag' = fromIntegral endTag
   let tag' = fromIntegral tag
   let nx' = realToFrac nx
   let ny' = realToFrac ny
   let nz' = realToFrac nz
   alloca $ \errptr -> do
      oval'' <- cgmshModelGeoAddEllipseArc startTag' centerTag' majorTag' endTag' tag' nx' ny' nz' errptr
      checkErrorCodeAndThrow "gmshModelGeoAddEllipseArc" errptr
      let oval''' = fromIntegral oval''
      return (oval''')
foreign import ccall safe "gmshc.h gmshModelGeoAddEllipseArc"
   cgmshModelGeoAddEllipseArc
      :: CInt
      -> CInt
      -> CInt
      -> CInt
      -> CInt
      -> CDouble
      -> CDouble
      -> CDouble
      -> Ptr CInt
      -> IO(CInt)
gmshModelGeoAddSpline :: [Int] -> Int -> IO(Int)
gmshModelGeoAddSpline pointTags tag = do
   withArrayIntLen pointTags $ \pointTags_n' pointTags' -> do
      let tag' = fromIntegral tag
      alloca $ \errptr -> do
         oval'' <- cgmshModelGeoAddSpline pointTags' pointTags_n' tag' errptr
         checkErrorCodeAndThrow "gmshModelGeoAddSpline" errptr
         let oval''' = fromIntegral oval''
         return (oval''')
foreign import ccall safe "gmshc.h gmshModelGeoAddSpline"
   cgmshModelGeoAddSpline
      :: Ptr CInt
      -> CInt
      -> CInt
      -> Ptr CInt
      -> IO(CInt)
gmshModelGeoAddBSpline :: [Int] -> Int -> IO(Int)
gmshModelGeoAddBSpline pointTags tag = do
   withArrayIntLen pointTags $ \pointTags_n' pointTags' -> do
      let tag' = fromIntegral tag
      alloca $ \errptr -> do
         oval'' <- cgmshModelGeoAddBSpline pointTags' pointTags_n' tag' errptr
         checkErrorCodeAndThrow "gmshModelGeoAddBSpline" errptr
         let oval''' = fromIntegral oval''
         return (oval''')
foreign import ccall safe "gmshc.h gmshModelGeoAddBSpline"
   cgmshModelGeoAddBSpline
      :: Ptr CInt
      -> CInt
      -> CInt
      -> Ptr CInt
      -> IO(CInt)
gmshModelGeoAddBezier :: [Int] -> Int -> IO(Int)
gmshModelGeoAddBezier pointTags tag = do
   withArrayIntLen pointTags $ \pointTags_n' pointTags' -> do
      let tag' = fromIntegral tag
      alloca $ \errptr -> do
         oval'' <- cgmshModelGeoAddBezier pointTags' pointTags_n' tag' errptr
         checkErrorCodeAndThrow "gmshModelGeoAddBezier" errptr
         let oval''' = fromIntegral oval''
         return (oval''')
foreign import ccall safe "gmshc.h gmshModelGeoAddBezier"
   cgmshModelGeoAddBezier
      :: Ptr CInt
      -> CInt
      -> CInt
      -> Ptr CInt
      -> IO(CInt)
gmshModelGeoAddCurveLoop :: [Int] -> Int -> IO(Int)
gmshModelGeoAddCurveLoop curveTags tag = do
   withArrayIntLen curveTags $ \curveTags_n' curveTags' -> do
      let tag' = fromIntegral tag
      alloca $ \errptr -> do
         oval'' <- cgmshModelGeoAddCurveLoop curveTags' curveTags_n' tag' errptr
         checkErrorCodeAndThrow "gmshModelGeoAddCurveLoop" errptr
         let oval''' = fromIntegral oval''
         return (oval''')
foreign import ccall safe "gmshc.h gmshModelGeoAddCurveLoop"
   cgmshModelGeoAddCurveLoop
      :: Ptr CInt
      -> CInt
      -> CInt
      -> Ptr CInt
      -> IO(CInt)
gmshModelGeoAddPlaneSurface :: [Int] -> Int -> IO(Int)
gmshModelGeoAddPlaneSurface wireTags tag = do
   withArrayIntLen wireTags $ \wireTags_n' wireTags' -> do
      let tag' = fromIntegral tag
      alloca $ \errptr -> do
         oval'' <- cgmshModelGeoAddPlaneSurface wireTags' wireTags_n' tag' errptr
         checkErrorCodeAndThrow "gmshModelGeoAddPlaneSurface" errptr
         let oval''' = fromIntegral oval''
         return (oval''')
foreign import ccall safe "gmshc.h gmshModelGeoAddPlaneSurface"
   cgmshModelGeoAddPlaneSurface
      :: Ptr CInt
      -> CInt
      -> CInt
      -> Ptr CInt
      -> IO(CInt)
gmshModelGeoAddSurfaceFilling :: [Int] -> Int -> Int -> IO(Int)
gmshModelGeoAddSurfaceFilling wireTags tag sphereCenterTag = do
   withArrayIntLen wireTags $ \wireTags_n' wireTags' -> do
      let tag' = fromIntegral tag
      let sphereCenterTag' = fromIntegral sphereCenterTag
      alloca $ \errptr -> do
         oval'' <- cgmshModelGeoAddSurfaceFilling wireTags' wireTags_n' tag' sphereCenterTag' errptr
         checkErrorCodeAndThrow "gmshModelGeoAddSurfaceFilling" errptr
         let oval''' = fromIntegral oval''
         return (oval''')
foreign import ccall safe "gmshc.h gmshModelGeoAddSurfaceFilling"
   cgmshModelGeoAddSurfaceFilling
      :: Ptr CInt
      -> CInt
      -> CInt
      -> CInt
      -> Ptr CInt
      -> IO(CInt)
gmshModelGeoAddSurfaceLoop :: [Int] -> Int -> IO(Int)
gmshModelGeoAddSurfaceLoop surfaceTags tag = do
   withArrayIntLen surfaceTags $ \surfaceTags_n' surfaceTags' -> do
      let tag' = fromIntegral tag
      alloca $ \errptr -> do
         oval'' <- cgmshModelGeoAddSurfaceLoop surfaceTags' surfaceTags_n' tag' errptr
         checkErrorCodeAndThrow "gmshModelGeoAddSurfaceLoop" errptr
         let oval''' = fromIntegral oval''
         return (oval''')
foreign import ccall safe "gmshc.h gmshModelGeoAddSurfaceLoop"
   cgmshModelGeoAddSurfaceLoop
      :: Ptr CInt
      -> CInt
      -> CInt
      -> Ptr CInt
      -> IO(CInt)
gmshModelGeoAddVolume :: [Int] -> Int -> IO(Int)
gmshModelGeoAddVolume shellTags tag = do
   withArrayIntLen shellTags $ \shellTags_n' shellTags' -> do
      let tag' = fromIntegral tag
      alloca $ \errptr -> do
         oval'' <- cgmshModelGeoAddVolume shellTags' shellTags_n' tag' errptr
         checkErrorCodeAndThrow "gmshModelGeoAddVolume" errptr
         let oval''' = fromIntegral oval''
         return (oval''')
foreign import ccall safe "gmshc.h gmshModelGeoAddVolume"
   cgmshModelGeoAddVolume
      :: Ptr CInt
      -> CInt
      -> CInt
      -> Ptr CInt
      -> IO(CInt)
gmshModelGeoExtrude :: [(Int, Int)] -> Double -> Double -> Double -> [Int] -> [Double] -> Bool -> IO([(Int,Int)])
gmshModelGeoExtrude dimTags dx dy dz numElements heights recombine = do
   withArrayPairLen dimTags $ \dimTags_n' dimTags' -> do
      let dx' = realToFrac dx
      let dy' = realToFrac dy
      let dz' = realToFrac dz
      withArrayIntLen numElements $ \numElements_n' numElements' -> do
         withArrayDoubleLen heights $ \heights_n' heights' -> do
            let recombine' = fromBool recombine
            alloca $ \outDimTags' -> do
               alloca $ \outDimTags_n' -> do
                  alloca $ \errptr -> do
                     cgmshModelGeoExtrude dimTags' dimTags_n' dx' dy' dz' outDimTags' outDimTags_n' numElements' numElements_n' heights' heights_n' recombine' errptr
                     checkErrorCodeAndThrow "gmshModelGeoExtrude" errptr
                     outDimTags'' <- peekArrayPairs outDimTags_n' outDimTags'
                     return (outDimTags'')
foreign import ccall safe "gmshc.h gmshModelGeoExtrude"
   cgmshModelGeoExtrude
      :: Ptr CInt
      -> CInt
      -> CDouble
      -> CDouble
      -> CDouble
      -> Ptr ( Ptr CInt)
      -> Ptr CInt
      -> Ptr CInt
      -> CInt
      -> Ptr CDouble
      -> CInt
      -> CBool
      -> Ptr CInt
      -> IO()
gmshModelGeoRevolve :: [(Int, Int)] -> Double -> Double -> Double -> Double -> Double -> Double -> Double -> [Int] -> [Double] -> Bool -> IO([(Int,Int)])
gmshModelGeoRevolve dimTags x y z ax ay az angle numElements heights recombine = do
   withArrayPairLen dimTags $ \dimTags_n' dimTags' -> do
      let x' = realToFrac x
      let y' = realToFrac y
      let z' = realToFrac z
      let ax' = realToFrac ax
      let ay' = realToFrac ay
      let az' = realToFrac az
      let angle' = realToFrac angle
      withArrayIntLen numElements $ \numElements_n' numElements' -> do
         withArrayDoubleLen heights $ \heights_n' heights' -> do
            let recombine' = fromBool recombine
            alloca $ \outDimTags' -> do
               alloca $ \outDimTags_n' -> do
                  alloca $ \errptr -> do
                     cgmshModelGeoRevolve dimTags' dimTags_n' x' y' z' ax' ay' az' angle' outDimTags' outDimTags_n' numElements' numElements_n' heights' heights_n' recombine' errptr
                     checkErrorCodeAndThrow "gmshModelGeoRevolve" errptr
                     outDimTags'' <- peekArrayPairs outDimTags_n' outDimTags'
                     return (outDimTags'')
foreign import ccall safe "gmshc.h gmshModelGeoRevolve"
   cgmshModelGeoRevolve
      :: Ptr CInt
      -> CInt
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> Ptr ( Ptr CInt)
      -> Ptr CInt
      -> Ptr CInt
      -> CInt
      -> Ptr CDouble
      -> CInt
      -> CBool
      -> Ptr CInt
      -> IO()
gmshModelGeoTwist :: [(Int, Int)] -> Double -> Double -> Double -> Double -> Double -> Double -> Double -> Double -> Double -> Double -> [Int] -> [Double] -> Bool -> IO([(Int,Int)])
gmshModelGeoTwist dimTags x y z dx dy dz ax ay az angle numElements heights recombine = do
   withArrayPairLen dimTags $ \dimTags_n' dimTags' -> do
      let x' = realToFrac x
      let y' = realToFrac y
      let z' = realToFrac z
      let dx' = realToFrac dx
      let dy' = realToFrac dy
      let dz' = realToFrac dz
      let ax' = realToFrac ax
      let ay' = realToFrac ay
      let az' = realToFrac az
      let angle' = realToFrac angle
      withArrayIntLen numElements $ \numElements_n' numElements' -> do
         withArrayDoubleLen heights $ \heights_n' heights' -> do
            let recombine' = fromBool recombine
            alloca $ \outDimTags' -> do
               alloca $ \outDimTags_n' -> do
                  alloca $ \errptr -> do
                     cgmshModelGeoTwist dimTags' dimTags_n' x' y' z' dx' dy' dz' ax' ay' az' angle' outDimTags' outDimTags_n' numElements' numElements_n' heights' heights_n' recombine' errptr
                     checkErrorCodeAndThrow "gmshModelGeoTwist" errptr
                     outDimTags'' <- peekArrayPairs outDimTags_n' outDimTags'
                     return (outDimTags'')
foreign import ccall safe "gmshc.h gmshModelGeoTwist"
   cgmshModelGeoTwist
      :: Ptr CInt
      -> CInt
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> Ptr ( Ptr CInt)
      -> Ptr CInt
      -> Ptr CInt
      -> CInt
      -> Ptr CDouble
      -> CInt
      -> CBool
      -> Ptr CInt
      -> IO()
gmshModelGeoTranslate :: [(Int, Int)] -> Double -> Double -> Double -> IO()
gmshModelGeoTranslate dimTags dx dy dz = do
   withArrayPairLen dimTags $ \dimTags_n' dimTags' -> do
      let dx' = realToFrac dx
      let dy' = realToFrac dy
      let dz' = realToFrac dz
      alloca $ \errptr -> do
         cgmshModelGeoTranslate dimTags' dimTags_n' dx' dy' dz' errptr
         checkErrorCodeAndThrow "gmshModelGeoTranslate" errptr
         return ()
foreign import ccall safe "gmshc.h gmshModelGeoTranslate"
   cgmshModelGeoTranslate
      :: Ptr CInt
      -> CInt
      -> CDouble
      -> CDouble
      -> CDouble
      -> Ptr CInt
      -> IO()
gmshModelGeoRotate :: [(Int, Int)] -> Double -> Double -> Double -> Double -> Double -> Double -> Double -> IO()
gmshModelGeoRotate dimTags x y z ax ay az angle = do
   withArrayPairLen dimTags $ \dimTags_n' dimTags' -> do
      let x' = realToFrac x
      let y' = realToFrac y
      let z' = realToFrac z
      let ax' = realToFrac ax
      let ay' = realToFrac ay
      let az' = realToFrac az
      let angle' = realToFrac angle
      alloca $ \errptr -> do
         cgmshModelGeoRotate dimTags' dimTags_n' x' y' z' ax' ay' az' angle' errptr
         checkErrorCodeAndThrow "gmshModelGeoRotate" errptr
         return ()
foreign import ccall safe "gmshc.h gmshModelGeoRotate"
   cgmshModelGeoRotate
      :: Ptr CInt
      -> CInt
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> Ptr CInt
      -> IO()
gmshModelGeoDilate :: [(Int, Int)] -> Double -> Double -> Double -> Double -> Double -> Double -> IO()
gmshModelGeoDilate dimTags x y z a b c = do
   withArrayPairLen dimTags $ \dimTags_n' dimTags' -> do
      let x' = realToFrac x
      let y' = realToFrac y
      let z' = realToFrac z
      let a' = realToFrac a
      let b' = realToFrac b
      let c' = realToFrac c
      alloca $ \errptr -> do
         cgmshModelGeoDilate dimTags' dimTags_n' x' y' z' a' b' c' errptr
         checkErrorCodeAndThrow "gmshModelGeoDilate" errptr
         return ()
foreign import ccall safe "gmshc.h gmshModelGeoDilate"
   cgmshModelGeoDilate
      :: Ptr CInt
      -> CInt
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> Ptr CInt
      -> IO()
gmshModelGeoSymmetrize :: [(Int, Int)] -> Double -> Double -> Double -> Double -> IO()
gmshModelGeoSymmetrize dimTags a b c d = do
   withArrayPairLen dimTags $ \dimTags_n' dimTags' -> do
      let a' = realToFrac a
      let b' = realToFrac b
      let c' = realToFrac c
      let d' = realToFrac d
      alloca $ \errptr -> do
         cgmshModelGeoSymmetrize dimTags' dimTags_n' a' b' c' d' errptr
         checkErrorCodeAndThrow "gmshModelGeoSymmetrize" errptr
         return ()
foreign import ccall safe "gmshc.h gmshModelGeoSymmetrize"
   cgmshModelGeoSymmetrize
      :: Ptr CInt
      -> CInt
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> Ptr CInt
      -> IO()
gmshModelGeoCopy :: [(Int, Int)] -> IO([(Int,Int)])
gmshModelGeoCopy dimTags = do
   withArrayPairLen dimTags $ \dimTags_n' dimTags' -> do
      alloca $ \outDimTags' -> do
         alloca $ \outDimTags_n' -> do
            alloca $ \errptr -> do
               cgmshModelGeoCopy dimTags' dimTags_n' outDimTags' outDimTags_n' errptr
               checkErrorCodeAndThrow "gmshModelGeoCopy" errptr
               outDimTags'' <- peekArrayPairs outDimTags_n' outDimTags'
               return (outDimTags'')
foreign import ccall safe "gmshc.h gmshModelGeoCopy"
   cgmshModelGeoCopy
      :: Ptr CInt
      -> CInt
      -> Ptr ( Ptr CInt)
      -> Ptr CInt
      -> Ptr CInt
      -> IO()
gmshModelGeoRemove :: [(Int, Int)] -> Bool -> IO()
gmshModelGeoRemove dimTags recursive = do
   withArrayPairLen dimTags $ \dimTags_n' dimTags' -> do
      let recursive' = fromBool recursive
      alloca $ \errptr -> do
         cgmshModelGeoRemove dimTags' dimTags_n' recursive' errptr
         checkErrorCodeAndThrow "gmshModelGeoRemove" errptr
         return ()
foreign import ccall safe "gmshc.h gmshModelGeoRemove"
   cgmshModelGeoRemove
      :: Ptr CInt
      -> CInt
      -> CBool
      -> Ptr CInt
      -> IO()
gmshModelGeoRemoveAllDuplicates :: IO()
gmshModelGeoRemoveAllDuplicates = do
   alloca $ \errptr -> do
      cgmshModelGeoRemoveAllDuplicates errptr
      checkErrorCodeAndThrow "gmshModelGeoRemoveAllDuplicates" errptr
      return ()
foreign import ccall safe "gmshc.h gmshModelGeoRemoveAllDuplicates"
   cgmshModelGeoRemoveAllDuplicates
      :: Ptr CInt
      -> IO()
gmshModelGeoSynchronize :: IO()
gmshModelGeoSynchronize = do
   alloca $ \errptr -> do
      cgmshModelGeoSynchronize errptr
      checkErrorCodeAndThrow "gmshModelGeoSynchronize" errptr
      return ()
foreign import ccall safe "gmshc.h gmshModelGeoSynchronize"
   cgmshModelGeoSynchronize
      :: Ptr CInt
      -> IO()
gmshModelGeoMeshSetSize :: [(Int, Int)] -> Double -> IO()
gmshModelGeoMeshSetSize dimTags size = do
   withArrayPairLen dimTags $ \dimTags_n' dimTags' -> do
      let size' = realToFrac size
      alloca $ \errptr -> do
         cgmshModelGeoMeshSetSize dimTags' dimTags_n' size' errptr
         checkErrorCodeAndThrow "gmshModelGeoMeshSetSize" errptr
         return ()
foreign import ccall safe "gmshc.h gmshModelGeoMeshSetSize"
   cgmshModelGeoMeshSetSize
      :: Ptr CInt
      -> CInt
      -> CDouble
      -> Ptr CInt
      -> IO()
gmshModelGeoMeshSetTransfiniteCurve :: Int -> Int -> String -> Double -> IO()
gmshModelGeoMeshSetTransfiniteCurve tag nPoints meshType coef = do
   let tag' = fromIntegral tag
   let nPoints' = fromIntegral nPoints
   withCString meshType $ \meshType' -> do
      let coef' = realToFrac coef
      alloca $ \errptr -> do
         cgmshModelGeoMeshSetTransfiniteCurve tag' nPoints' meshType' coef' errptr
         checkErrorCodeAndThrow "gmshModelGeoMeshSetTransfiniteCurve" errptr
         return ()
foreign import ccall safe "gmshc.h gmshModelGeoMeshSetTransfiniteCurve"
   cgmshModelGeoMeshSetTransfiniteCurve
      :: CInt
      -> CInt
      -> CString
      -> CDouble
      -> Ptr CInt
      -> IO()
gmshModelGeoMeshSetTransfiniteSurface :: Int -> String -> [Int] -> IO()
gmshModelGeoMeshSetTransfiniteSurface tag arrangement cornerTags = do
   let tag' = fromIntegral tag
   withCString arrangement $ \arrangement' -> do
      withArrayIntLen cornerTags $ \cornerTags_n' cornerTags' -> do
         alloca $ \errptr -> do
            cgmshModelGeoMeshSetTransfiniteSurface tag' arrangement' cornerTags' cornerTags_n' errptr
            checkErrorCodeAndThrow "gmshModelGeoMeshSetTransfiniteSurface" errptr
            return ()
foreign import ccall safe "gmshc.h gmshModelGeoMeshSetTransfiniteSurface"
   cgmshModelGeoMeshSetTransfiniteSurface
      :: CInt
      -> CString
      -> Ptr CInt
      -> CInt
      -> Ptr CInt
      -> IO()
gmshModelGeoMeshSetTransfiniteVolume :: Int -> [Int] -> IO()
gmshModelGeoMeshSetTransfiniteVolume tag cornerTags = do
   let tag' = fromIntegral tag
   withArrayIntLen cornerTags $ \cornerTags_n' cornerTags' -> do
      alloca $ \errptr -> do
         cgmshModelGeoMeshSetTransfiniteVolume tag' cornerTags' cornerTags_n' errptr
         checkErrorCodeAndThrow "gmshModelGeoMeshSetTransfiniteVolume" errptr
         return ()
foreign import ccall safe "gmshc.h gmshModelGeoMeshSetTransfiniteVolume"
   cgmshModelGeoMeshSetTransfiniteVolume
      :: CInt
      -> Ptr CInt
      -> CInt
      -> Ptr CInt
      -> IO()
gmshModelGeoMeshSetRecombine :: Int -> Int -> Double -> IO()
gmshModelGeoMeshSetRecombine dim tag angle = do
   let dim' = fromIntegral dim
   let tag' = fromIntegral tag
   let angle' = realToFrac angle
   alloca $ \errptr -> do
      cgmshModelGeoMeshSetRecombine dim' tag' angle' errptr
      checkErrorCodeAndThrow "gmshModelGeoMeshSetRecombine" errptr
      return ()
foreign import ccall safe "gmshc.h gmshModelGeoMeshSetRecombine"
   cgmshModelGeoMeshSetRecombine
      :: CInt
      -> CInt
      -> CDouble
      -> Ptr CInt
      -> IO()
gmshModelGeoMeshSetSmoothing :: Int -> Int -> Int -> IO()
gmshModelGeoMeshSetSmoothing dim tag val = do
   let dim' = fromIntegral dim
   let tag' = fromIntegral tag
   let val' = fromIntegral val
   alloca $ \errptr -> do
      cgmshModelGeoMeshSetSmoothing dim' tag' val' errptr
      checkErrorCodeAndThrow "gmshModelGeoMeshSetSmoothing" errptr
      return ()
foreign import ccall safe "gmshc.h gmshModelGeoMeshSetSmoothing"
   cgmshModelGeoMeshSetSmoothing
      :: CInt
      -> CInt
      -> CInt
      -> Ptr CInt
      -> IO()
gmshModelGeoMeshSetReverse :: Int -> Int -> Bool -> IO()
gmshModelGeoMeshSetReverse dim tag val = do
   let dim' = fromIntegral dim
   let tag' = fromIntegral tag
   let val' = fromBool val
   alloca $ \errptr -> do
      cgmshModelGeoMeshSetReverse dim' tag' val' errptr
      checkErrorCodeAndThrow "gmshModelGeoMeshSetReverse" errptr
      return ()
foreign import ccall safe "gmshc.h gmshModelGeoMeshSetReverse"
   cgmshModelGeoMeshSetReverse
      :: CInt
      -> CInt
      -> CBool
      -> Ptr CInt
      -> IO()
gmshModelOccAddPoint :: Double -> Double -> Double -> Double -> Int -> IO(Int)
gmshModelOccAddPoint x y z meshSize tag = do
   let x' = realToFrac x
   let y' = realToFrac y
   let z' = realToFrac z
   let meshSize' = realToFrac meshSize
   let tag' = fromIntegral tag
   alloca $ \errptr -> do
      oval'' <- cgmshModelOccAddPoint x' y' z' meshSize' tag' errptr
      checkErrorCodeAndThrow "gmshModelOccAddPoint" errptr
      let oval''' = fromIntegral oval''
      return (oval''')
foreign import ccall safe "gmshc.h gmshModelOccAddPoint"
   cgmshModelOccAddPoint
      :: CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CInt
      -> Ptr CInt
      -> IO(CInt)
gmshModelOccAddLine :: Int -> Int -> Int -> IO(Int)
gmshModelOccAddLine startTag endTag tag = do
   let startTag' = fromIntegral startTag
   let endTag' = fromIntegral endTag
   let tag' = fromIntegral tag
   alloca $ \errptr -> do
      oval'' <- cgmshModelOccAddLine startTag' endTag' tag' errptr
      checkErrorCodeAndThrow "gmshModelOccAddLine" errptr
      let oval''' = fromIntegral oval''
      return (oval''')
foreign import ccall safe "gmshc.h gmshModelOccAddLine"
   cgmshModelOccAddLine
      :: CInt
      -> CInt
      -> CInt
      -> Ptr CInt
      -> IO(CInt)
gmshModelOccAddCircleArc :: Int -> Int -> Int -> Int -> IO(Int)
gmshModelOccAddCircleArc startTag centerTag endTag tag = do
   let startTag' = fromIntegral startTag
   let centerTag' = fromIntegral centerTag
   let endTag' = fromIntegral endTag
   let tag' = fromIntegral tag
   alloca $ \errptr -> do
      oval'' <- cgmshModelOccAddCircleArc startTag' centerTag' endTag' tag' errptr
      checkErrorCodeAndThrow "gmshModelOccAddCircleArc" errptr
      let oval''' = fromIntegral oval''
      return (oval''')
foreign import ccall safe "gmshc.h gmshModelOccAddCircleArc"
   cgmshModelOccAddCircleArc
      :: CInt
      -> CInt
      -> CInt
      -> CInt
      -> Ptr CInt
      -> IO(CInt)
gmshModelOccAddCircle :: Double -> Double -> Double -> Double -> Int -> Double -> Double -> IO(Int)
gmshModelOccAddCircle x y z r tag angle1 angle2 = do
   let x' = realToFrac x
   let y' = realToFrac y
   let z' = realToFrac z
   let r' = realToFrac r
   let tag' = fromIntegral tag
   let angle1' = realToFrac angle1
   let angle2' = realToFrac angle2
   alloca $ \errptr -> do
      oval'' <- cgmshModelOccAddCircle x' y' z' r' tag' angle1' angle2' errptr
      checkErrorCodeAndThrow "gmshModelOccAddCircle" errptr
      let oval''' = fromIntegral oval''
      return (oval''')
foreign import ccall safe "gmshc.h gmshModelOccAddCircle"
   cgmshModelOccAddCircle
      :: CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CInt
      -> CDouble
      -> CDouble
      -> Ptr CInt
      -> IO(CInt)
gmshModelOccAddEllipseArc :: Int -> Int -> Int -> Int -> Int -> IO(Int)
gmshModelOccAddEllipseArc startTag centerTag majorTag endTag tag = do
   let startTag' = fromIntegral startTag
   let centerTag' = fromIntegral centerTag
   let majorTag' = fromIntegral majorTag
   let endTag' = fromIntegral endTag
   let tag' = fromIntegral tag
   alloca $ \errptr -> do
      oval'' <- cgmshModelOccAddEllipseArc startTag' centerTag' majorTag' endTag' tag' errptr
      checkErrorCodeAndThrow "gmshModelOccAddEllipseArc" errptr
      let oval''' = fromIntegral oval''
      return (oval''')
foreign import ccall safe "gmshc.h gmshModelOccAddEllipseArc"
   cgmshModelOccAddEllipseArc
      :: CInt
      -> CInt
      -> CInt
      -> CInt
      -> CInt
      -> Ptr CInt
      -> IO(CInt)
gmshModelOccAddEllipse :: Double -> Double -> Double -> Double -> Double -> Int -> Double -> Double -> IO(Int)
gmshModelOccAddEllipse x y z r1 r2 tag angle1 angle2 = do
   let x' = realToFrac x
   let y' = realToFrac y
   let z' = realToFrac z
   let r1' = realToFrac r1
   let r2' = realToFrac r2
   let tag' = fromIntegral tag
   let angle1' = realToFrac angle1
   let angle2' = realToFrac angle2
   alloca $ \errptr -> do
      oval'' <- cgmshModelOccAddEllipse x' y' z' r1' r2' tag' angle1' angle2' errptr
      checkErrorCodeAndThrow "gmshModelOccAddEllipse" errptr
      let oval''' = fromIntegral oval''
      return (oval''')
foreign import ccall safe "gmshc.h gmshModelOccAddEllipse"
   cgmshModelOccAddEllipse
      :: CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CInt
      -> CDouble
      -> CDouble
      -> Ptr CInt
      -> IO(CInt)
gmshModelOccAddSpline :: [Int] -> Int -> IO(Int)
gmshModelOccAddSpline pointTags tag = do
   withArrayIntLen pointTags $ \pointTags_n' pointTags' -> do
      let tag' = fromIntegral tag
      alloca $ \errptr -> do
         oval'' <- cgmshModelOccAddSpline pointTags' pointTags_n' tag' errptr
         checkErrorCodeAndThrow "gmshModelOccAddSpline" errptr
         let oval''' = fromIntegral oval''
         return (oval''')
foreign import ccall safe "gmshc.h gmshModelOccAddSpline"
   cgmshModelOccAddSpline
      :: Ptr CInt
      -> CInt
      -> CInt
      -> Ptr CInt
      -> IO(CInt)
gmshModelOccAddBSpline :: [Int] -> Int -> Int -> [Double] -> [Double] -> [Int] -> IO(Int)
gmshModelOccAddBSpline pointTags tag degree weights knots multiplicities = do
   withArrayIntLen pointTags $ \pointTags_n' pointTags' -> do
      let tag' = fromIntegral tag
      let degree' = fromIntegral degree
      withArrayDoubleLen weights $ \weights_n' weights' -> do
         withArrayDoubleLen knots $ \knots_n' knots' -> do
            withArrayIntLen multiplicities $ \multiplicities_n' multiplicities' -> do
               alloca $ \errptr -> do
                  oval'' <- cgmshModelOccAddBSpline pointTags' pointTags_n' tag' degree' weights' weights_n' knots' knots_n' multiplicities' multiplicities_n' errptr
                  checkErrorCodeAndThrow "gmshModelOccAddBSpline" errptr
                  let oval''' = fromIntegral oval''
                  return (oval''')
foreign import ccall safe "gmshc.h gmshModelOccAddBSpline"
   cgmshModelOccAddBSpline
      :: Ptr CInt
      -> CInt
      -> CInt
      -> CInt
      -> Ptr CDouble
      -> CInt
      -> Ptr CDouble
      -> CInt
      -> Ptr CInt
      -> CInt
      -> Ptr CInt
      -> IO(CInt)
gmshModelOccAddBezier :: [Int] -> Int -> IO(Int)
gmshModelOccAddBezier pointTags tag = do
   withArrayIntLen pointTags $ \pointTags_n' pointTags' -> do
      let tag' = fromIntegral tag
      alloca $ \errptr -> do
         oval'' <- cgmshModelOccAddBezier pointTags' pointTags_n' tag' errptr
         checkErrorCodeAndThrow "gmshModelOccAddBezier" errptr
         let oval''' = fromIntegral oval''
         return (oval''')
foreign import ccall safe "gmshc.h gmshModelOccAddBezier"
   cgmshModelOccAddBezier
      :: Ptr CInt
      -> CInt
      -> CInt
      -> Ptr CInt
      -> IO(CInt)
gmshModelOccAddWire :: [Int] -> Int -> Bool -> IO(Int)
gmshModelOccAddWire curveTags tag checkClosed = do
   withArrayIntLen curveTags $ \curveTags_n' curveTags' -> do
      let tag' = fromIntegral tag
      let checkClosed' = fromBool checkClosed
      alloca $ \errptr -> do
         oval'' <- cgmshModelOccAddWire curveTags' curveTags_n' tag' checkClosed' errptr
         checkErrorCodeAndThrow "gmshModelOccAddWire" errptr
         let oval''' = fromIntegral oval''
         return (oval''')
foreign import ccall safe "gmshc.h gmshModelOccAddWire"
   cgmshModelOccAddWire
      :: Ptr CInt
      -> CInt
      -> CInt
      -> CBool
      -> Ptr CInt
      -> IO(CInt)
gmshModelOccAddCurveLoop :: [Int] -> Int -> IO(Int)
gmshModelOccAddCurveLoop curveTags tag = do
   withArrayIntLen curveTags $ \curveTags_n' curveTags' -> do
      let tag' = fromIntegral tag
      alloca $ \errptr -> do
         oval'' <- cgmshModelOccAddCurveLoop curveTags' curveTags_n' tag' errptr
         checkErrorCodeAndThrow "gmshModelOccAddCurveLoop" errptr
         let oval''' = fromIntegral oval''
         return (oval''')
foreign import ccall safe "gmshc.h gmshModelOccAddCurveLoop"
   cgmshModelOccAddCurveLoop
      :: Ptr CInt
      -> CInt
      -> CInt
      -> Ptr CInt
      -> IO(CInt)
gmshModelOccAddRectangle :: Double -> Double -> Double -> Double -> Double -> Int -> Double -> IO(Int)
gmshModelOccAddRectangle x y z dx dy tag roundedRadius = do
   let x' = realToFrac x
   let y' = realToFrac y
   let z' = realToFrac z
   let dx' = realToFrac dx
   let dy' = realToFrac dy
   let tag' = fromIntegral tag
   let roundedRadius' = realToFrac roundedRadius
   alloca $ \errptr -> do
      oval'' <- cgmshModelOccAddRectangle x' y' z' dx' dy' tag' roundedRadius' errptr
      checkErrorCodeAndThrow "gmshModelOccAddRectangle" errptr
      let oval''' = fromIntegral oval''
      return (oval''')
foreign import ccall safe "gmshc.h gmshModelOccAddRectangle"
   cgmshModelOccAddRectangle
      :: CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CInt
      -> CDouble
      -> Ptr CInt
      -> IO(CInt)
gmshModelOccAddDisk :: Double -> Double -> Double -> Double -> Double -> Int -> IO(Int)
gmshModelOccAddDisk xc yc zc rx ry tag = do
   let xc' = realToFrac xc
   let yc' = realToFrac yc
   let zc' = realToFrac zc
   let rx' = realToFrac rx
   let ry' = realToFrac ry
   let tag' = fromIntegral tag
   alloca $ \errptr -> do
      oval'' <- cgmshModelOccAddDisk xc' yc' zc' rx' ry' tag' errptr
      checkErrorCodeAndThrow "gmshModelOccAddDisk" errptr
      let oval''' = fromIntegral oval''
      return (oval''')
foreign import ccall safe "gmshc.h gmshModelOccAddDisk"
   cgmshModelOccAddDisk
      :: CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CInt
      -> Ptr CInt
      -> IO(CInt)
gmshModelOccAddPlaneSurface :: [Int] -> Int -> IO(Int)
gmshModelOccAddPlaneSurface wireTags tag = do
   withArrayIntLen wireTags $ \wireTags_n' wireTags' -> do
      let tag' = fromIntegral tag
      alloca $ \errptr -> do
         oval'' <- cgmshModelOccAddPlaneSurface wireTags' wireTags_n' tag' errptr
         checkErrorCodeAndThrow "gmshModelOccAddPlaneSurface" errptr
         let oval''' = fromIntegral oval''
         return (oval''')
foreign import ccall safe "gmshc.h gmshModelOccAddPlaneSurface"
   cgmshModelOccAddPlaneSurface
      :: Ptr CInt
      -> CInt
      -> CInt
      -> Ptr CInt
      -> IO(CInt)
gmshModelOccAddSurfaceFilling :: Int -> Int -> [Int] -> IO(Int)
gmshModelOccAddSurfaceFilling wireTag tag pointTags = do
   let wireTag' = fromIntegral wireTag
   let tag' = fromIntegral tag
   withArrayIntLen pointTags $ \pointTags_n' pointTags' -> do
      alloca $ \errptr -> do
         oval'' <- cgmshModelOccAddSurfaceFilling wireTag' tag' pointTags' pointTags_n' errptr
         checkErrorCodeAndThrow "gmshModelOccAddSurfaceFilling" errptr
         let oval''' = fromIntegral oval''
         return (oval''')
foreign import ccall safe "gmshc.h gmshModelOccAddSurfaceFilling"
   cgmshModelOccAddSurfaceFilling
      :: CInt
      -> CInt
      -> Ptr CInt
      -> CInt
      -> Ptr CInt
      -> IO(CInt)
gmshModelOccAddSurfaceLoop :: [Int] -> Int -> Bool -> IO(Int)
gmshModelOccAddSurfaceLoop surfaceTags tag sewing = do
   withArrayIntLen surfaceTags $ \surfaceTags_n' surfaceTags' -> do
      let tag' = fromIntegral tag
      let sewing' = fromBool sewing
      alloca $ \errptr -> do
         oval'' <- cgmshModelOccAddSurfaceLoop surfaceTags' surfaceTags_n' tag' sewing' errptr
         checkErrorCodeAndThrow "gmshModelOccAddSurfaceLoop" errptr
         let oval''' = fromIntegral oval''
         return (oval''')
foreign import ccall safe "gmshc.h gmshModelOccAddSurfaceLoop"
   cgmshModelOccAddSurfaceLoop
      :: Ptr CInt
      -> CInt
      -> CInt
      -> CBool
      -> Ptr CInt
      -> IO(CInt)
gmshModelOccAddVolume :: [Int] -> Int -> IO(Int)
gmshModelOccAddVolume shellTags tag = do
   withArrayIntLen shellTags $ \shellTags_n' shellTags' -> do
      let tag' = fromIntegral tag
      alloca $ \errptr -> do
         oval'' <- cgmshModelOccAddVolume shellTags' shellTags_n' tag' errptr
         checkErrorCodeAndThrow "gmshModelOccAddVolume" errptr
         let oval''' = fromIntegral oval''
         return (oval''')
foreign import ccall safe "gmshc.h gmshModelOccAddVolume"
   cgmshModelOccAddVolume
      :: Ptr CInt
      -> CInt
      -> CInt
      -> Ptr CInt
      -> IO(CInt)
gmshModelOccAddSphere :: Double -> Double -> Double -> Double -> Int -> Double -> Double -> Double -> IO(Int)
gmshModelOccAddSphere xc yc zc radius tag angle1 angle2 angle3 = do
   let xc' = realToFrac xc
   let yc' = realToFrac yc
   let zc' = realToFrac zc
   let radius' = realToFrac radius
   let tag' = fromIntegral tag
   let angle1' = realToFrac angle1
   let angle2' = realToFrac angle2
   let angle3' = realToFrac angle3
   alloca $ \errptr -> do
      oval'' <- cgmshModelOccAddSphere xc' yc' zc' radius' tag' angle1' angle2' angle3' errptr
      checkErrorCodeAndThrow "gmshModelOccAddSphere" errptr
      let oval''' = fromIntegral oval''
      return (oval''')
foreign import ccall safe "gmshc.h gmshModelOccAddSphere"
   cgmshModelOccAddSphere
      :: CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CInt
      -> CDouble
      -> CDouble
      -> CDouble
      -> Ptr CInt
      -> IO(CInt)
gmshModelOccAddBox :: Double -> Double -> Double -> Double -> Double -> Double -> Int -> IO(Int)
gmshModelOccAddBox x y z dx dy dz tag = do
   let x' = realToFrac x
   let y' = realToFrac y
   let z' = realToFrac z
   let dx' = realToFrac dx
   let dy' = realToFrac dy
   let dz' = realToFrac dz
   let tag' = fromIntegral tag
   alloca $ \errptr -> do
      oval'' <- cgmshModelOccAddBox x' y' z' dx' dy' dz' tag' errptr
      checkErrorCodeAndThrow "gmshModelOccAddBox" errptr
      let oval''' = fromIntegral oval''
      return (oval''')
foreign import ccall safe "gmshc.h gmshModelOccAddBox"
   cgmshModelOccAddBox
      :: CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CInt
      -> Ptr CInt
      -> IO(CInt)
gmshModelOccAddCylinder :: Double -> Double -> Double -> Double -> Double -> Double -> Double -> Int -> Double -> IO(Int)
gmshModelOccAddCylinder x y z dx dy dz r tag angle = do
   let x' = realToFrac x
   let y' = realToFrac y
   let z' = realToFrac z
   let dx' = realToFrac dx
   let dy' = realToFrac dy
   let dz' = realToFrac dz
   let r' = realToFrac r
   let tag' = fromIntegral tag
   let angle' = realToFrac angle
   alloca $ \errptr -> do
      oval'' <- cgmshModelOccAddCylinder x' y' z' dx' dy' dz' r' tag' angle' errptr
      checkErrorCodeAndThrow "gmshModelOccAddCylinder" errptr
      let oval''' = fromIntegral oval''
      return (oval''')
foreign import ccall safe "gmshc.h gmshModelOccAddCylinder"
   cgmshModelOccAddCylinder
      :: CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CInt
      -> CDouble
      -> Ptr CInt
      -> IO(CInt)
gmshModelOccAddCone :: Double -> Double -> Double -> Double -> Double -> Double -> Double -> Double -> Int -> Double -> IO(Int)
gmshModelOccAddCone x y z dx dy dz r1 r2 tag angle = do
   let x' = realToFrac x
   let y' = realToFrac y
   let z' = realToFrac z
   let dx' = realToFrac dx
   let dy' = realToFrac dy
   let dz' = realToFrac dz
   let r1' = realToFrac r1
   let r2' = realToFrac r2
   let tag' = fromIntegral tag
   let angle' = realToFrac angle
   alloca $ \errptr -> do
      oval'' <- cgmshModelOccAddCone x' y' z' dx' dy' dz' r1' r2' tag' angle' errptr
      checkErrorCodeAndThrow "gmshModelOccAddCone" errptr
      let oval''' = fromIntegral oval''
      return (oval''')
foreign import ccall safe "gmshc.h gmshModelOccAddCone"
   cgmshModelOccAddCone
      :: CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CInt
      -> CDouble
      -> Ptr CInt
      -> IO(CInt)
gmshModelOccAddWedge :: Double -> Double -> Double -> Double -> Double -> Double -> Int -> Double -> IO(Int)
gmshModelOccAddWedge x y z dx dy dz tag ltx = do
   let x' = realToFrac x
   let y' = realToFrac y
   let z' = realToFrac z
   let dx' = realToFrac dx
   let dy' = realToFrac dy
   let dz' = realToFrac dz
   let tag' = fromIntegral tag
   let ltx' = realToFrac ltx
   alloca $ \errptr -> do
      oval'' <- cgmshModelOccAddWedge x' y' z' dx' dy' dz' tag' ltx' errptr
      checkErrorCodeAndThrow "gmshModelOccAddWedge" errptr
      let oval''' = fromIntegral oval''
      return (oval''')
foreign import ccall safe "gmshc.h gmshModelOccAddWedge"
   cgmshModelOccAddWedge
      :: CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CInt
      -> CDouble
      -> Ptr CInt
      -> IO(CInt)
gmshModelOccAddTorus :: Double -> Double -> Double -> Double -> Double -> Int -> Double -> IO(Int)
gmshModelOccAddTorus x y z r1 r2 tag angle = do
   let x' = realToFrac x
   let y' = realToFrac y
   let z' = realToFrac z
   let r1' = realToFrac r1
   let r2' = realToFrac r2
   let tag' = fromIntegral tag
   let angle' = realToFrac angle
   alloca $ \errptr -> do
      oval'' <- cgmshModelOccAddTorus x' y' z' r1' r2' tag' angle' errptr
      checkErrorCodeAndThrow "gmshModelOccAddTorus" errptr
      let oval''' = fromIntegral oval''
      return (oval''')
foreign import ccall safe "gmshc.h gmshModelOccAddTorus"
   cgmshModelOccAddTorus
      :: CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CInt
      -> CDouble
      -> Ptr CInt
      -> IO(CInt)
gmshModelOccAddThruSections :: [Int] -> Int -> Bool -> Bool -> IO([(Int,Int)])
gmshModelOccAddThruSections wireTags tag makeSolid makeRuled = do
   withArrayIntLen wireTags $ \wireTags_n' wireTags' -> do
      let tag' = fromIntegral tag
      let makeSolid' = fromBool makeSolid
      let makeRuled' = fromBool makeRuled
      alloca $ \outDimTags' -> do
         alloca $ \outDimTags_n' -> do
            alloca $ \errptr -> do
               cgmshModelOccAddThruSections wireTags' wireTags_n' outDimTags' outDimTags_n' tag' makeSolid' makeRuled' errptr
               checkErrorCodeAndThrow "gmshModelOccAddThruSections" errptr
               outDimTags'' <- peekArrayPairs outDimTags_n' outDimTags'
               return (outDimTags'')
foreign import ccall safe "gmshc.h gmshModelOccAddThruSections"
   cgmshModelOccAddThruSections
      :: Ptr CInt
      -> CInt
      -> Ptr ( Ptr CInt)
      -> Ptr CInt
      -> CInt
      -> CBool
      -> CBool
      -> Ptr CInt
      -> IO()
gmshModelOccAddThickSolid :: Int -> [Int] -> Double -> Int -> IO([(Int,Int)])
gmshModelOccAddThickSolid volumeTag excludeSurfaceTags offset tag = do
   let volumeTag' = fromIntegral volumeTag
   withArrayIntLen excludeSurfaceTags $ \excludeSurfaceTags_n' excludeSurfaceTags' -> do
      let offset' = realToFrac offset
      let tag' = fromIntegral tag
      alloca $ \outDimTags' -> do
         alloca $ \outDimTags_n' -> do
            alloca $ \errptr -> do
               cgmshModelOccAddThickSolid volumeTag' excludeSurfaceTags' excludeSurfaceTags_n' offset' outDimTags' outDimTags_n' tag' errptr
               checkErrorCodeAndThrow "gmshModelOccAddThickSolid" errptr
               outDimTags'' <- peekArrayPairs outDimTags_n' outDimTags'
               return (outDimTags'')
foreign import ccall safe "gmshc.h gmshModelOccAddThickSolid"
   cgmshModelOccAddThickSolid
      :: CInt
      -> Ptr CInt
      -> CInt
      -> CDouble
      -> Ptr ( Ptr CInt)
      -> Ptr CInt
      -> CInt
      -> Ptr CInt
      -> IO()
gmshModelOccExtrude :: [(Int, Int)] -> Double -> Double -> Double -> [Int] -> [Double] -> Bool -> IO([(Int,Int)])
gmshModelOccExtrude dimTags dx dy dz numElements heights recombine = do
   withArrayPairLen dimTags $ \dimTags_n' dimTags' -> do
      let dx' = realToFrac dx
      let dy' = realToFrac dy
      let dz' = realToFrac dz
      withArrayIntLen numElements $ \numElements_n' numElements' -> do
         withArrayDoubleLen heights $ \heights_n' heights' -> do
            let recombine' = fromBool recombine
            alloca $ \outDimTags' -> do
               alloca $ \outDimTags_n' -> do
                  alloca $ \errptr -> do
                     cgmshModelOccExtrude dimTags' dimTags_n' dx' dy' dz' outDimTags' outDimTags_n' numElements' numElements_n' heights' heights_n' recombine' errptr
                     checkErrorCodeAndThrow "gmshModelOccExtrude" errptr
                     outDimTags'' <- peekArrayPairs outDimTags_n' outDimTags'
                     return (outDimTags'')
foreign import ccall safe "gmshc.h gmshModelOccExtrude"
   cgmshModelOccExtrude
      :: Ptr CInt
      -> CInt
      -> CDouble
      -> CDouble
      -> CDouble
      -> Ptr ( Ptr CInt)
      -> Ptr CInt
      -> Ptr CInt
      -> CInt
      -> Ptr CDouble
      -> CInt
      -> CBool
      -> Ptr CInt
      -> IO()
gmshModelOccRevolve :: [(Int, Int)] -> Double -> Double -> Double -> Double -> Double -> Double -> Double -> [Int] -> [Double] -> Bool -> IO([(Int,Int)])
gmshModelOccRevolve dimTags x y z ax ay az angle numElements heights recombine = do
   withArrayPairLen dimTags $ \dimTags_n' dimTags' -> do
      let x' = realToFrac x
      let y' = realToFrac y
      let z' = realToFrac z
      let ax' = realToFrac ax
      let ay' = realToFrac ay
      let az' = realToFrac az
      let angle' = realToFrac angle
      withArrayIntLen numElements $ \numElements_n' numElements' -> do
         withArrayDoubleLen heights $ \heights_n' heights' -> do
            let recombine' = fromBool recombine
            alloca $ \outDimTags' -> do
               alloca $ \outDimTags_n' -> do
                  alloca $ \errptr -> do
                     cgmshModelOccRevolve dimTags' dimTags_n' x' y' z' ax' ay' az' angle' outDimTags' outDimTags_n' numElements' numElements_n' heights' heights_n' recombine' errptr
                     checkErrorCodeAndThrow "gmshModelOccRevolve" errptr
                     outDimTags'' <- peekArrayPairs outDimTags_n' outDimTags'
                     return (outDimTags'')
foreign import ccall safe "gmshc.h gmshModelOccRevolve"
   cgmshModelOccRevolve
      :: Ptr CInt
      -> CInt
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> Ptr ( Ptr CInt)
      -> Ptr CInt
      -> Ptr CInt
      -> CInt
      -> Ptr CDouble
      -> CInt
      -> CBool
      -> Ptr CInt
      -> IO()
gmshModelOccAddPipe :: [(Int, Int)] -> Int -> IO([(Int,Int)])
gmshModelOccAddPipe dimTags wireTag = do
   withArrayPairLen dimTags $ \dimTags_n' dimTags' -> do
      let wireTag' = fromIntegral wireTag
      alloca $ \outDimTags' -> do
         alloca $ \outDimTags_n' -> do
            alloca $ \errptr -> do
               cgmshModelOccAddPipe dimTags' dimTags_n' wireTag' outDimTags' outDimTags_n' errptr
               checkErrorCodeAndThrow "gmshModelOccAddPipe" errptr
               outDimTags'' <- peekArrayPairs outDimTags_n' outDimTags'
               return (outDimTags'')
foreign import ccall safe "gmshc.h gmshModelOccAddPipe"
   cgmshModelOccAddPipe
      :: Ptr CInt
      -> CInt
      -> CInt
      -> Ptr ( Ptr CInt)
      -> Ptr CInt
      -> Ptr CInt
      -> IO()
gmshModelOccFillet :: [Int] -> [Int] -> [Double] -> Bool -> IO([(Int,Int)])
gmshModelOccFillet volumeTags curveTags radii removeVolume = do
   withArrayIntLen volumeTags $ \volumeTags_n' volumeTags' -> do
      withArrayIntLen curveTags $ \curveTags_n' curveTags' -> do
         withArrayDoubleLen radii $ \radii_n' radii' -> do
            let removeVolume' = fromBool removeVolume
            alloca $ \outDimTags' -> do
               alloca $ \outDimTags_n' -> do
                  alloca $ \errptr -> do
                     cgmshModelOccFillet volumeTags' volumeTags_n' curveTags' curveTags_n' radii' radii_n' outDimTags' outDimTags_n' removeVolume' errptr
                     checkErrorCodeAndThrow "gmshModelOccFillet" errptr
                     outDimTags'' <- peekArrayPairs outDimTags_n' outDimTags'
                     return (outDimTags'')
foreign import ccall safe "gmshc.h gmshModelOccFillet"
   cgmshModelOccFillet
      :: Ptr CInt
      -> CInt
      -> Ptr CInt
      -> CInt
      -> Ptr CDouble
      -> CInt
      -> Ptr ( Ptr CInt)
      -> Ptr CInt
      -> CBool
      -> Ptr CInt
      -> IO()
gmshModelOccChamfer :: [Int] -> [Int] -> [Int] -> [Double] -> Bool -> IO([(Int,Int)])
gmshModelOccChamfer volumeTags curveTags surfaceTags distances removeVolume = do
   withArrayIntLen volumeTags $ \volumeTags_n' volumeTags' -> do
      withArrayIntLen curveTags $ \curveTags_n' curveTags' -> do
         withArrayIntLen surfaceTags $ \surfaceTags_n' surfaceTags' -> do
            withArrayDoubleLen distances $ \distances_n' distances' -> do
               let removeVolume' = fromBool removeVolume
               alloca $ \outDimTags' -> do
                  alloca $ \outDimTags_n' -> do
                     alloca $ \errptr -> do
                        cgmshModelOccChamfer volumeTags' volumeTags_n' curveTags' curveTags_n' surfaceTags' surfaceTags_n' distances' distances_n' outDimTags' outDimTags_n' removeVolume' errptr
                        checkErrorCodeAndThrow "gmshModelOccChamfer" errptr
                        outDimTags'' <- peekArrayPairs outDimTags_n' outDimTags'
                        return (outDimTags'')
foreign import ccall safe "gmshc.h gmshModelOccChamfer"
   cgmshModelOccChamfer
      :: Ptr CInt
      -> CInt
      -> Ptr CInt
      -> CInt
      -> Ptr CInt
      -> CInt
      -> Ptr CDouble
      -> CInt
      -> Ptr ( Ptr CInt)
      -> Ptr CInt
      -> CBool
      -> Ptr CInt
      -> IO()
gmshModelOccFuse :: [(Int, Int)] -> [(Int, Int)] -> Int -> Bool -> Bool -> IO([(Int,Int)], [[(Int, Int)]])
gmshModelOccFuse objectDimTags toolDimTags tag removeObject removeTool = do
   withArrayPairLen objectDimTags $ \objectDimTags_n' objectDimTags' -> do
      withArrayPairLen toolDimTags $ \toolDimTags_n' toolDimTags' -> do
         let tag' = fromIntegral tag
         let removeObject' = fromBool removeObject
         let removeTool' = fromBool removeTool
         alloca $ \outDimTags' -> do
            alloca $ \outDimTags_n' -> do
               alloca $ \outDimTagsMap' -> do
                  alloca $ \outDimTagsMap_n' -> do
                     alloca $ \outDimTagsMap_nn' -> do
                        alloca $ \errptr -> do
                           cgmshModelOccFuse objectDimTags' objectDimTags_n' toolDimTags' toolDimTags_n' outDimTags' outDimTags_n' outDimTagsMap' outDimTagsMap_n' outDimTagsMap_nn' tag' removeObject' removeTool' errptr
                           checkErrorCodeAndThrow "gmshModelOccFuse" errptr
                           outDimTags'' <- peekArrayPairs outDimTags_n' outDimTags'
                           outDimTagsMap'' <- peekArrayArrayPairs outDimTagsMap_nn' outDimTagsMap_n' outDimTagsMap'
                           return (outDimTags'', outDimTagsMap'')
foreign import ccall safe "gmshc.h gmshModelOccFuse"
   cgmshModelOccFuse
      :: Ptr CInt
      -> CInt
      -> Ptr CInt
      -> CInt
      -> Ptr ( Ptr CInt)
      -> Ptr CInt
      -> Ptr (Ptr (Ptr CInt))
      -> Ptr (Ptr CInt)
      -> Ptr CInt
      -> CInt
      -> CBool
      -> CBool
      -> Ptr CInt
      -> IO()
gmshModelOccIntersect :: [(Int, Int)] -> [(Int, Int)] -> Int -> Bool -> Bool -> IO([(Int,Int)], [[(Int, Int)]])
gmshModelOccIntersect objectDimTags toolDimTags tag removeObject removeTool = do
   withArrayPairLen objectDimTags $ \objectDimTags_n' objectDimTags' -> do
      withArrayPairLen toolDimTags $ \toolDimTags_n' toolDimTags' -> do
         let tag' = fromIntegral tag
         let removeObject' = fromBool removeObject
         let removeTool' = fromBool removeTool
         alloca $ \outDimTags' -> do
            alloca $ \outDimTags_n' -> do
               alloca $ \outDimTagsMap' -> do
                  alloca $ \outDimTagsMap_n' -> do
                     alloca $ \outDimTagsMap_nn' -> do
                        alloca $ \errptr -> do
                           cgmshModelOccIntersect objectDimTags' objectDimTags_n' toolDimTags' toolDimTags_n' outDimTags' outDimTags_n' outDimTagsMap' outDimTagsMap_n' outDimTagsMap_nn' tag' removeObject' removeTool' errptr
                           checkErrorCodeAndThrow "gmshModelOccIntersect" errptr
                           outDimTags'' <- peekArrayPairs outDimTags_n' outDimTags'
                           outDimTagsMap'' <- peekArrayArrayPairs outDimTagsMap_nn' outDimTagsMap_n' outDimTagsMap'
                           return (outDimTags'', outDimTagsMap'')
foreign import ccall safe "gmshc.h gmshModelOccIntersect"
   cgmshModelOccIntersect
      :: Ptr CInt
      -> CInt
      -> Ptr CInt
      -> CInt
      -> Ptr ( Ptr CInt)
      -> Ptr CInt
      -> Ptr (Ptr (Ptr CInt))
      -> Ptr (Ptr CInt)
      -> Ptr CInt
      -> CInt
      -> CBool
      -> CBool
      -> Ptr CInt
      -> IO()
gmshModelOccCut :: [(Int, Int)] -> [(Int, Int)] -> Int -> Bool -> Bool -> IO([(Int,Int)], [[(Int, Int)]])
gmshModelOccCut objectDimTags toolDimTags tag removeObject removeTool = do
   withArrayPairLen objectDimTags $ \objectDimTags_n' objectDimTags' -> do
      withArrayPairLen toolDimTags $ \toolDimTags_n' toolDimTags' -> do
         let tag' = fromIntegral tag
         let removeObject' = fromBool removeObject
         let removeTool' = fromBool removeTool
         alloca $ \outDimTags' -> do
            alloca $ \outDimTags_n' -> do
               alloca $ \outDimTagsMap' -> do
                  alloca $ \outDimTagsMap_n' -> do
                     alloca $ \outDimTagsMap_nn' -> do
                        alloca $ \errptr -> do
                           cgmshModelOccCut objectDimTags' objectDimTags_n' toolDimTags' toolDimTags_n' outDimTags' outDimTags_n' outDimTagsMap' outDimTagsMap_n' outDimTagsMap_nn' tag' removeObject' removeTool' errptr
                           checkErrorCodeAndThrow "gmshModelOccCut" errptr
                           outDimTags'' <- peekArrayPairs outDimTags_n' outDimTags'
                           outDimTagsMap'' <- peekArrayArrayPairs outDimTagsMap_nn' outDimTagsMap_n' outDimTagsMap'
                           return (outDimTags'', outDimTagsMap'')
foreign import ccall safe "gmshc.h gmshModelOccCut"
   cgmshModelOccCut
      :: Ptr CInt
      -> CInt
      -> Ptr CInt
      -> CInt
      -> Ptr ( Ptr CInt)
      -> Ptr CInt
      -> Ptr (Ptr (Ptr CInt))
      -> Ptr (Ptr CInt)
      -> Ptr CInt
      -> CInt
      -> CBool
      -> CBool
      -> Ptr CInt
      -> IO()
gmshModelOccFragment :: [(Int, Int)] -> [(Int, Int)] -> Int -> Bool -> Bool -> IO([(Int,Int)], [[(Int, Int)]])
gmshModelOccFragment objectDimTags toolDimTags tag removeObject removeTool = do
   withArrayPairLen objectDimTags $ \objectDimTags_n' objectDimTags' -> do
      withArrayPairLen toolDimTags $ \toolDimTags_n' toolDimTags' -> do
         let tag' = fromIntegral tag
         let removeObject' = fromBool removeObject
         let removeTool' = fromBool removeTool
         alloca $ \outDimTags' -> do
            alloca $ \outDimTags_n' -> do
               alloca $ \outDimTagsMap' -> do
                  alloca $ \outDimTagsMap_n' -> do
                     alloca $ \outDimTagsMap_nn' -> do
                        alloca $ \errptr -> do
                           cgmshModelOccFragment objectDimTags' objectDimTags_n' toolDimTags' toolDimTags_n' outDimTags' outDimTags_n' outDimTagsMap' outDimTagsMap_n' outDimTagsMap_nn' tag' removeObject' removeTool' errptr
                           checkErrorCodeAndThrow "gmshModelOccFragment" errptr
                           outDimTags'' <- peekArrayPairs outDimTags_n' outDimTags'
                           outDimTagsMap'' <- peekArrayArrayPairs outDimTagsMap_nn' outDimTagsMap_n' outDimTagsMap'
                           return (outDimTags'', outDimTagsMap'')
foreign import ccall safe "gmshc.h gmshModelOccFragment"
   cgmshModelOccFragment
      :: Ptr CInt
      -> CInt
      -> Ptr CInt
      -> CInt
      -> Ptr ( Ptr CInt)
      -> Ptr CInt
      -> Ptr (Ptr (Ptr CInt))
      -> Ptr (Ptr CInt)
      -> Ptr CInt
      -> CInt
      -> CBool
      -> CBool
      -> Ptr CInt
      -> IO()
gmshModelOccTranslate :: [(Int, Int)] -> Double -> Double -> Double -> IO()
gmshModelOccTranslate dimTags dx dy dz = do
   withArrayPairLen dimTags $ \dimTags_n' dimTags' -> do
      let dx' = realToFrac dx
      let dy' = realToFrac dy
      let dz' = realToFrac dz
      alloca $ \errptr -> do
         cgmshModelOccTranslate dimTags' dimTags_n' dx' dy' dz' errptr
         checkErrorCodeAndThrow "gmshModelOccTranslate" errptr
         return ()
foreign import ccall safe "gmshc.h gmshModelOccTranslate"
   cgmshModelOccTranslate
      :: Ptr CInt
      -> CInt
      -> CDouble
      -> CDouble
      -> CDouble
      -> Ptr CInt
      -> IO()
gmshModelOccRotate :: [(Int, Int)] -> Double -> Double -> Double -> Double -> Double -> Double -> Double -> IO()
gmshModelOccRotate dimTags x y z ax ay az angle = do
   withArrayPairLen dimTags $ \dimTags_n' dimTags' -> do
      let x' = realToFrac x
      let y' = realToFrac y
      let z' = realToFrac z
      let ax' = realToFrac ax
      let ay' = realToFrac ay
      let az' = realToFrac az
      let angle' = realToFrac angle
      alloca $ \errptr -> do
         cgmshModelOccRotate dimTags' dimTags_n' x' y' z' ax' ay' az' angle' errptr
         checkErrorCodeAndThrow "gmshModelOccRotate" errptr
         return ()
foreign import ccall safe "gmshc.h gmshModelOccRotate"
   cgmshModelOccRotate
      :: Ptr CInt
      -> CInt
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> Ptr CInt
      -> IO()
gmshModelOccDilate :: [(Int, Int)] -> Double -> Double -> Double -> Double -> Double -> Double -> IO()
gmshModelOccDilate dimTags x y z a b c = do
   withArrayPairLen dimTags $ \dimTags_n' dimTags' -> do
      let x' = realToFrac x
      let y' = realToFrac y
      let z' = realToFrac z
      let a' = realToFrac a
      let b' = realToFrac b
      let c' = realToFrac c
      alloca $ \errptr -> do
         cgmshModelOccDilate dimTags' dimTags_n' x' y' z' a' b' c' errptr
         checkErrorCodeAndThrow "gmshModelOccDilate" errptr
         return ()
foreign import ccall safe "gmshc.h gmshModelOccDilate"
   cgmshModelOccDilate
      :: Ptr CInt
      -> CInt
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> Ptr CInt
      -> IO()
gmshModelOccSymmetrize :: [(Int, Int)] -> Double -> Double -> Double -> Double -> IO()
gmshModelOccSymmetrize dimTags a b c d = do
   withArrayPairLen dimTags $ \dimTags_n' dimTags' -> do
      let a' = realToFrac a
      let b' = realToFrac b
      let c' = realToFrac c
      let d' = realToFrac d
      alloca $ \errptr -> do
         cgmshModelOccSymmetrize dimTags' dimTags_n' a' b' c' d' errptr
         checkErrorCodeAndThrow "gmshModelOccSymmetrize" errptr
         return ()
foreign import ccall safe "gmshc.h gmshModelOccSymmetrize"
   cgmshModelOccSymmetrize
      :: Ptr CInt
      -> CInt
      -> CDouble
      -> CDouble
      -> CDouble
      -> CDouble
      -> Ptr CInt
      -> IO()
gmshModelOccAffineTransform :: [(Int, Int)] -> [Double] -> IO()
gmshModelOccAffineTransform dimTags a = do
   withArrayPairLen dimTags $ \dimTags_n' dimTags' -> do
      withArrayDoubleLen a $ \a_n' a' -> do
         alloca $ \errptr -> do
            cgmshModelOccAffineTransform dimTags' dimTags_n' a' a_n' errptr
            checkErrorCodeAndThrow "gmshModelOccAffineTransform" errptr
            return ()
foreign import ccall safe "gmshc.h gmshModelOccAffineTransform"
   cgmshModelOccAffineTransform
      :: Ptr CInt
      -> CInt
      -> Ptr CDouble
      -> CInt
      -> Ptr CInt
      -> IO()
gmshModelOccCopy :: [(Int, Int)] -> IO([(Int,Int)])
gmshModelOccCopy dimTags = do
   withArrayPairLen dimTags $ \dimTags_n' dimTags' -> do
      alloca $ \outDimTags' -> do
         alloca $ \outDimTags_n' -> do
            alloca $ \errptr -> do
               cgmshModelOccCopy dimTags' dimTags_n' outDimTags' outDimTags_n' errptr
               checkErrorCodeAndThrow "gmshModelOccCopy" errptr
               outDimTags'' <- peekArrayPairs outDimTags_n' outDimTags'
               return (outDimTags'')
foreign import ccall safe "gmshc.h gmshModelOccCopy"
   cgmshModelOccCopy
      :: Ptr CInt
      -> CInt
      -> Ptr ( Ptr CInt)
      -> Ptr CInt
      -> Ptr CInt
      -> IO()
gmshModelOccRemove :: [(Int, Int)] -> Bool -> IO()
gmshModelOccRemove dimTags recursive = do
   withArrayPairLen dimTags $ \dimTags_n' dimTags' -> do
      let recursive' = fromBool recursive
      alloca $ \errptr -> do
         cgmshModelOccRemove dimTags' dimTags_n' recursive' errptr
         checkErrorCodeAndThrow "gmshModelOccRemove" errptr
         return ()
foreign import ccall safe "gmshc.h gmshModelOccRemove"
   cgmshModelOccRemove
      :: Ptr CInt
      -> CInt
      -> CBool
      -> Ptr CInt
      -> IO()
gmshModelOccRemoveAllDuplicates :: IO()
gmshModelOccRemoveAllDuplicates = do
   alloca $ \errptr -> do
      cgmshModelOccRemoveAllDuplicates errptr
      checkErrorCodeAndThrow "gmshModelOccRemoveAllDuplicates" errptr
      return ()
foreign import ccall safe "gmshc.h gmshModelOccRemoveAllDuplicates"
   cgmshModelOccRemoveAllDuplicates
      :: Ptr CInt
      -> IO()
gmshModelOccHealShapes :: [(Int, Int)] -> Double -> Bool -> Bool -> Bool -> Bool -> IO([(Int,Int)])
gmshModelOccHealShapes dimTags tolerance fixDegenerated fixSmallEdges fixSmallFaces sewFaces = do
   withArrayPairLen dimTags $ \dimTags_n' dimTags' -> do
      let tolerance' = realToFrac tolerance
      let fixDegenerated' = fromBool fixDegenerated
      let fixSmallEdges' = fromBool fixSmallEdges
      let fixSmallFaces' = fromBool fixSmallFaces
      let sewFaces' = fromBool sewFaces
      alloca $ \outDimTags' -> do
         alloca $ \outDimTags_n' -> do
            alloca $ \errptr -> do
               cgmshModelOccHealShapes outDimTags' outDimTags_n' dimTags' dimTags_n' tolerance' fixDegenerated' fixSmallEdges' fixSmallFaces' sewFaces' errptr
               checkErrorCodeAndThrow "gmshModelOccHealShapes" errptr
               outDimTags'' <- peekArrayPairs outDimTags_n' outDimTags'
               return (outDimTags'')
foreign import ccall safe "gmshc.h gmshModelOccHealShapes"
   cgmshModelOccHealShapes
      :: Ptr ( Ptr CInt)
      -> Ptr CInt
      -> Ptr CInt
      -> CInt
      -> CDouble
      -> CBool
      -> CBool
      -> CBool
      -> CBool
      -> Ptr CInt
      -> IO()
gmshModelOccImportShapes :: String -> Bool -> String -> IO([(Int,Int)])
gmshModelOccImportShapes fileName highestDimOnly format = do
   withCString fileName $ \fileName' -> do
      let highestDimOnly' = fromBool highestDimOnly
      withCString format $ \format' -> do
         alloca $ \outDimTags' -> do
            alloca $ \outDimTags_n' -> do
               alloca $ \errptr -> do
                  cgmshModelOccImportShapes fileName' outDimTags' outDimTags_n' highestDimOnly' format' errptr
                  checkErrorCodeAndThrow "gmshModelOccImportShapes" errptr
                  outDimTags'' <- peekArrayPairs outDimTags_n' outDimTags'
                  return (outDimTags'')
foreign import ccall safe "gmshc.h gmshModelOccImportShapes"
   cgmshModelOccImportShapes
      :: CString
      -> Ptr ( Ptr CInt)
      -> Ptr CInt
      -> CBool
      -> CString
      -> Ptr CInt
      -> IO()
gmshModelOccSetMeshSize :: [(Int, Int)] -> Double -> IO()
gmshModelOccSetMeshSize dimTags size = do
   withArrayPairLen dimTags $ \dimTags_n' dimTags' -> do
      let size' = realToFrac size
      alloca $ \errptr -> do
         cgmshModelOccSetMeshSize dimTags' dimTags_n' size' errptr
         checkErrorCodeAndThrow "gmshModelOccSetMeshSize" errptr
         return ()
foreign import ccall safe "gmshc.h gmshModelOccSetMeshSize"
   cgmshModelOccSetMeshSize
      :: Ptr CInt
      -> CInt
      -> CDouble
      -> Ptr CInt
      -> IO()
gmshModelOccGetMass :: Int -> Int -> IO(Double)
gmshModelOccGetMass dim tag = do
   let dim' = fromIntegral dim
   let tag' = fromIntegral tag
   alloca $ \mass' -> do
      alloca $ \errptr -> do
         cgmshModelOccGetMass dim' tag' mass' errptr
         checkErrorCodeAndThrow "gmshModelOccGetMass" errptr
         mass'' <- peek mass'
         let mass''' = realToFrac mass''
         return (mass''')
foreign import ccall safe "gmshc.h gmshModelOccGetMass"
   cgmshModelOccGetMass
      :: CInt
      -> CInt
      -> Ptr CDouble
      -> Ptr CInt
      -> IO()
gmshModelOccGetCenterOfMass :: Int -> Int -> IO(Double, Double, Double)
gmshModelOccGetCenterOfMass dim tag = do
   let dim' = fromIntegral dim
   let tag' = fromIntegral tag
   alloca $ \x' -> do
      alloca $ \y' -> do
         alloca $ \z' -> do
            alloca $ \errptr -> do
               cgmshModelOccGetCenterOfMass dim' tag' x' y' z' errptr
               checkErrorCodeAndThrow "gmshModelOccGetCenterOfMass" errptr
               x'' <- peek x'
               let x''' = realToFrac x''
               y'' <- peek y'
               let y''' = realToFrac y''
               z'' <- peek z'
               let z''' = realToFrac z''
               return (x''', y''', z''')
foreign import ccall safe "gmshc.h gmshModelOccGetCenterOfMass"
   cgmshModelOccGetCenterOfMass
      :: CInt
      -> CInt
      -> Ptr CDouble
      -> Ptr CDouble
      -> Ptr CDouble
      -> Ptr CInt
      -> IO()
gmshModelOccGetMatrixOfInertia :: Int -> Int -> IO([Double])
gmshModelOccGetMatrixOfInertia dim tag = do
   let dim' = fromIntegral dim
   let tag' = fromIntegral tag
   alloca $ \mat' -> do
      alloca $ \mat_n' -> do
         alloca $ \errptr -> do
            cgmshModelOccGetMatrixOfInertia dim' tag' mat' mat_n' errptr
            checkErrorCodeAndThrow "gmshModelOccGetMatrixOfInertia" errptr
            mat'' <- peekArrayDouble mat_n' mat'
            return (mat'')
foreign import ccall safe "gmshc.h gmshModelOccGetMatrixOfInertia"
   cgmshModelOccGetMatrixOfInertia
      :: CInt
      -> CInt
      -> Ptr ( Ptr CDouble)
      -> Ptr CInt
      -> Ptr CInt
      -> IO()
gmshModelOccSynchronize :: IO()
gmshModelOccSynchronize = do
   alloca $ \errptr -> do
      cgmshModelOccSynchronize errptr
      checkErrorCodeAndThrow "gmshModelOccSynchronize" errptr
      return ()
foreign import ccall safe "gmshc.h gmshModelOccSynchronize"
   cgmshModelOccSynchronize
      :: Ptr CInt
      -> IO()
gmshViewAdd :: String -> Int -> IO(Int)
gmshViewAdd name tag = do
   withCString name $ \name' -> do
      let tag' = fromIntegral tag
      alloca $ \errptr -> do
         oval'' <- cgmshViewAdd name' tag' errptr
         checkErrorCodeAndThrow "gmshViewAdd" errptr
         let oval''' = fromIntegral oval''
         return (oval''')
foreign import ccall safe "gmshc.h gmshViewAdd"
   cgmshViewAdd
      :: CString
      -> CInt
      -> Ptr CInt
      -> IO(CInt)
gmshViewRemove :: Int -> IO()
gmshViewRemove tag = do
   let tag' = fromIntegral tag
   alloca $ \errptr -> do
      cgmshViewRemove tag' errptr
      checkErrorCodeAndThrow "gmshViewRemove" errptr
      return ()
foreign import ccall safe "gmshc.h gmshViewRemove"
   cgmshViewRemove
      :: CInt
      -> Ptr CInt
      -> IO()
gmshViewGetIndex :: Int -> IO(Int)
gmshViewGetIndex tag = do
   let tag' = fromIntegral tag
   alloca $ \errptr -> do
      oval'' <- cgmshViewGetIndex tag' errptr
      checkErrorCodeAndThrow "gmshViewGetIndex" errptr
      let oval''' = fromIntegral oval''
      return (oval''')
foreign import ccall safe "gmshc.h gmshViewGetIndex"
   cgmshViewGetIndex
      :: CInt
      -> Ptr CInt
      -> IO(CInt)
gmshViewGetTags :: IO([Int])
gmshViewGetTags = do
   alloca $ \tags' -> do
      alloca $ \tags_n' -> do
         alloca $ \errptr -> do
            cgmshViewGetTags tags' tags_n' errptr
            checkErrorCodeAndThrow "gmshViewGetTags" errptr
            tags'' <- peekArrayInt tags_n' tags'
            return (tags'')
foreign import ccall safe "gmshc.h gmshViewGetTags"
   cgmshViewGetTags
      :: Ptr ( Ptr CInt)
      -> Ptr CInt
      -> Ptr CInt
      -> IO()
gmshViewAddModelData :: Int -> Int -> String -> String -> [Int] -> [[Double]] -> Double -> Int -> Int -> IO()
gmshViewAddModelData tag step modelName dataType tags daatta time numComponents partition = do
   let tag' = fromIntegral tag
   let step' = fromIntegral step
   withCString modelName $ \modelName' -> do
      withCString dataType $ \dataType' -> do
         withArrayIntLen tags $ \tags_n' tags' -> do
            withArrayArrayDoubleLen daatta $ \daatta_nn' daatta_n' daatta' -> do
                  let time' = realToFrac time
                  let numComponents' = fromIntegral numComponents
                  let partition' = fromIntegral partition
                  alloca $ \errptr -> do
                     cgmshViewAddModelData tag' step' modelName' dataType' tags' tags_n' daatta' daatta_n' daatta_nn' time' numComponents' partition' errptr
                     checkErrorCodeAndThrow "gmshViewAddModelData" errptr
                     return ()
foreign import ccall safe "gmshc.h gmshViewAddModelData"
   cgmshViewAddModelData
      :: CInt
      -> CInt
      -> CString
      -> CString
      -> Ptr CInt
      -> CInt
      -> Ptr (Ptr CDouble)
      -> Ptr CInt
      -> CInt
      -> CDouble
      -> CInt
      -> CInt
      -> Ptr CInt
      -> IO()
gmshViewGetModelData :: Int -> Int -> IO(String, [Int], [[Double]], Double, Int)
gmshViewGetModelData tag step = do
   let tag' = fromIntegral tag
   let step' = fromIntegral step
   alloca $ \dataType' -> do
      alloca $ \tags' -> do
         alloca $ \tags_n' -> do
            alloca $ \daatta' -> do
               alloca $ \daatta_n' -> do
                  alloca $ \daatta_nn' -> do
                     alloca $ \time' -> do
                        alloca $ \numComponents' -> do
                           alloca $ \errptr -> do
                              cgmshViewGetModelData tag' step' dataType' tags' tags_n' daatta' daatta_n' daatta_nn' time' numComponents' errptr
                              checkErrorCodeAndThrow "gmshViewGetModelData" errptr
                              dataType'' <- peek dataType'
                              dataType''' <- peekCString dataType''
                              tags'' <- peekArrayInt tags_n' tags'
                              daatta'' <- peekArrayArrayDouble daatta_nn' daatta_n' daatta'
                              time'' <- peek time'
                              let time''' = realToFrac time''
                              numComponents'' <- peek numComponents'
                              let numComponents''' = fromIntegral numComponents''
                              return (dataType''', tags'', daatta'', time''', numComponents''')
foreign import ccall safe "gmshc.h gmshViewGetModelData"
   cgmshViewGetModelData
      :: CInt
      -> CInt
      -> Ptr CString
      -> Ptr ( Ptr CInt)
      -> Ptr CInt
      -> Ptr (Ptr (Ptr CDouble))
      -> Ptr (Ptr CInt)
      -> Ptr CInt
      -> Ptr CDouble
      -> Ptr CInt
      -> Ptr CInt
      -> IO()
gmshViewAddListData :: Int -> String -> Int -> [Double] -> IO()
gmshViewAddListData tag dataType numEle daatta = do
   let tag' = fromIntegral tag
   withCString dataType $ \dataType' -> do
      let numEle' = fromIntegral numEle
      withArrayDoubleLen daatta $ \daatta_n' daatta' -> do
         alloca $ \errptr -> do
            cgmshViewAddListData tag' dataType' numEle' daatta' daatta_n' errptr
            checkErrorCodeAndThrow "gmshViewAddListData" errptr
            return ()
foreign import ccall safe "gmshc.h gmshViewAddListData"
   cgmshViewAddListData
      :: CInt
      -> CString
      -> CInt
      -> Ptr CDouble
      -> CInt
      -> Ptr CInt
      -> IO()
gmshViewGetListData :: Int -> IO([String], [Int], [[Double]])
gmshViewGetListData tag = do
   let tag' = fromIntegral tag
   alloca $ \dataType' -> do
      alloca $ \dataType_n' -> do
         alloca $ \numElements' -> do
            alloca $ \numElements_n' -> do
               alloca $ \daatta' -> do
                  alloca $ \daatta_n' -> do
                     alloca $ \daatta_nn' -> do
                        alloca $ \errptr -> do
                           cgmshViewGetListData tag' dataType' dataType_n' numElements' numElements_n' daatta' daatta_n' daatta_nn' errptr
                           checkErrorCodeAndThrow "gmshViewGetListData" errptr
                           dataType'' <- peekArrayString dataType_n' dataType'
                           numElements'' <- peekArrayInt numElements_n' numElements'
                           daatta'' <- peekArrayArrayDouble daatta_nn' daatta_n' daatta'
                           return (dataType'', numElements'', daatta'')
foreign import ccall safe "gmshc.h gmshViewGetListData"
   cgmshViewGetListData
      :: CInt
      -> Ptr ( Ptr CString)
      -> Ptr CInt
      -> Ptr ( Ptr CInt)
      -> Ptr CInt
      -> Ptr (Ptr (Ptr CDouble))
      -> Ptr (Ptr CInt)
      -> Ptr CInt
      -> Ptr CInt
      -> IO()
gmshViewAddAlias :: Int -> Bool -> Int -> IO(Int)
gmshViewAddAlias refTag copyOptions tag = do
   let refTag' = fromIntegral refTag
   let copyOptions' = fromBool copyOptions
   let tag' = fromIntegral tag
   alloca $ \errptr -> do
      oval'' <- cgmshViewAddAlias refTag' copyOptions' tag' errptr
      checkErrorCodeAndThrow "gmshViewAddAlias" errptr
      let oval''' = fromIntegral oval''
      return (oval''')
foreign import ccall safe "gmshc.h gmshViewAddAlias"
   cgmshViewAddAlias
      :: CInt
      -> CBool
      -> CInt
      -> Ptr CInt
      -> IO(CInt)
gmshViewCopyOptions :: Int -> Int -> IO()
gmshViewCopyOptions refTag tag = do
   let refTag' = fromIntegral refTag
   let tag' = fromIntegral tag
   alloca $ \errptr -> do
      cgmshViewCopyOptions refTag' tag' errptr
      checkErrorCodeAndThrow "gmshViewCopyOptions" errptr
      return ()
foreign import ccall safe "gmshc.h gmshViewCopyOptions"
   cgmshViewCopyOptions
      :: CInt
      -> CInt
      -> Ptr CInt
      -> IO()
gmshViewCombine :: String -> String -> Bool -> IO()
gmshViewCombine what how remove = do
   withCString what $ \what' -> do
      withCString how $ \how' -> do
         let remove' = fromBool remove
         alloca $ \errptr -> do
            cgmshViewCombine what' how' remove' errptr
            checkErrorCodeAndThrow "gmshViewCombine" errptr
            return ()
foreign import ccall safe "gmshc.h gmshViewCombine"
   cgmshViewCombine
      :: CString
      -> CString
      -> CBool
      -> Ptr CInt
      -> IO()
gmshViewProbe :: Int -> Double -> Double -> Double -> Int -> Int -> Bool -> Double -> [Double] -> [Double] -> [Double] -> IO([Double])
gmshViewProbe tag x y z step numComp gradient tolerance xElemCoord yElemCoord zElemCoord = do
   let tag' = fromIntegral tag
   let x' = realToFrac x
   let y' = realToFrac y
   let z' = realToFrac z
   let step' = fromIntegral step
   let numComp' = fromIntegral numComp
   let gradient' = fromBool gradient
   let tolerance' = realToFrac tolerance
   withArrayDoubleLen xElemCoord $ \xElemCoord_n' xElemCoord' -> do
      withArrayDoubleLen yElemCoord $ \yElemCoord_n' yElemCoord' -> do
         withArrayDoubleLen zElemCoord $ \zElemCoord_n' zElemCoord' -> do
            alloca $ \value' -> do
               alloca $ \value_n' -> do
                  alloca $ \errptr -> do
                     cgmshViewProbe tag' x' y' z' value' value_n' step' numComp' gradient' tolerance' xElemCoord' xElemCoord_n' yElemCoord' yElemCoord_n' zElemCoord' zElemCoord_n' errptr
                     checkErrorCodeAndThrow "gmshViewProbe" errptr
                     value'' <- peekArrayDouble value_n' value'
                     return (value'')
foreign import ccall safe "gmshc.h gmshViewProbe"
   cgmshViewProbe
      :: CInt
      -> CDouble
      -> CDouble
      -> CDouble
      -> Ptr ( Ptr CDouble)
      -> Ptr CInt
      -> CInt
      -> CInt
      -> CBool
      -> CDouble
      -> Ptr CDouble
      -> CInt
      -> Ptr CDouble
      -> CInt
      -> Ptr CDouble
      -> CInt
      -> Ptr CInt
      -> IO()
gmshViewWrite :: Int -> String -> Bool -> IO()
gmshViewWrite tag fileName append = do
   let tag' = fromIntegral tag
   withCString fileName $ \fileName' -> do
      let append' = fromBool append
      alloca $ \errptr -> do
         cgmshViewWrite tag' fileName' append' errptr
         checkErrorCodeAndThrow "gmshViewWrite" errptr
         return ()
foreign import ccall safe "gmshc.h gmshViewWrite"
   cgmshViewWrite
      :: CInt
      -> CString
      -> CBool
      -> Ptr CInt
      -> IO()
gmshPluginSetNumber :: String -> String -> Double -> IO()
gmshPluginSetNumber name option value = do
   withCString name $ \name' -> do
      withCString option $ \option' -> do
         let value' = realToFrac value
         alloca $ \errptr -> do
            cgmshPluginSetNumber name' option' value' errptr
            checkErrorCodeAndThrow "gmshPluginSetNumber" errptr
            return ()
foreign import ccall safe "gmshc.h gmshPluginSetNumber"
   cgmshPluginSetNumber
      :: CString
      -> CString
      -> CDouble
      -> Ptr CInt
      -> IO()
gmshPluginSetString :: String -> String -> String -> IO()
gmshPluginSetString name option value = do
   withCString name $ \name' -> do
      withCString option $ \option' -> do
         withCString value $ \value' -> do
            alloca $ \errptr -> do
               cgmshPluginSetString name' option' value' errptr
               checkErrorCodeAndThrow "gmshPluginSetString" errptr
               return ()
foreign import ccall safe "gmshc.h gmshPluginSetString"
   cgmshPluginSetString
      :: CString
      -> CString
      -> CString
      -> Ptr CInt
      -> IO()
gmshPluginRun :: String -> IO()
gmshPluginRun name = do
   withCString name $ \name' -> do
      alloca $ \errptr -> do
         cgmshPluginRun name' errptr
         checkErrorCodeAndThrow "gmshPluginRun" errptr
         return ()
foreign import ccall safe "gmshc.h gmshPluginRun"
   cgmshPluginRun
      :: CString
      -> Ptr CInt
      -> IO()
gmshGraphicsDraw :: IO()
gmshGraphicsDraw = do
   alloca $ \errptr -> do
      cgmshGraphicsDraw errptr
      checkErrorCodeAndThrow "gmshGraphicsDraw" errptr
      return ()
foreign import ccall safe "gmshc.h gmshGraphicsDraw"
   cgmshGraphicsDraw
      :: Ptr CInt
      -> IO()
gmshFltkInitialize :: IO()
gmshFltkInitialize = do
   alloca $ \errptr -> do
      cgmshFltkInitialize errptr
      checkErrorCodeAndThrow "gmshFltkInitialize" errptr
      return ()
foreign import ccall safe "gmshc.h gmshFltkInitialize"
   cgmshFltkInitialize
      :: Ptr CInt
      -> IO()
gmshFltkWait :: Double -> IO()
gmshFltkWait time = do
   let time' = realToFrac time
   alloca $ \errptr -> do
      cgmshFltkWait time' errptr
      checkErrorCodeAndThrow "gmshFltkWait" errptr
      return ()
foreign import ccall safe "gmshc.h gmshFltkWait"
   cgmshFltkWait
      :: CDouble
      -> Ptr CInt
      -> IO()
gmshFltkUpdate :: IO()
gmshFltkUpdate = do
   alloca $ \errptr -> do
      cgmshFltkUpdate errptr
      checkErrorCodeAndThrow "gmshFltkUpdate" errptr
      return ()
foreign import ccall safe "gmshc.h gmshFltkUpdate"
   cgmshFltkUpdate
      :: Ptr CInt
      -> IO()
gmshFltkAwake :: String -> IO()
gmshFltkAwake action = do
   withCString action $ \action' -> do
      alloca $ \errptr -> do
         cgmshFltkAwake action' errptr
         checkErrorCodeAndThrow "gmshFltkAwake" errptr
         return ()
foreign import ccall safe "gmshc.h gmshFltkAwake"
   cgmshFltkAwake
      :: CString
      -> Ptr CInt
      -> IO()
gmshFltkLock :: IO()
gmshFltkLock = do
   alloca $ \errptr -> do
      cgmshFltkLock errptr
      checkErrorCodeAndThrow "gmshFltkLock" errptr
      return ()
foreign import ccall safe "gmshc.h gmshFltkLock"
   cgmshFltkLock
      :: Ptr CInt
      -> IO()
gmshFltkUnlock :: IO()
gmshFltkUnlock = do
   alloca $ \errptr -> do
      cgmshFltkUnlock errptr
      checkErrorCodeAndThrow "gmshFltkUnlock" errptr
      return ()
foreign import ccall safe "gmshc.h gmshFltkUnlock"
   cgmshFltkUnlock
      :: Ptr CInt
      -> IO()
gmshFltkRun :: IO()
gmshFltkRun = do
   alloca $ \errptr -> do
      cgmshFltkRun errptr
      checkErrorCodeAndThrow "gmshFltkRun" errptr
      return ()
foreign import ccall safe "gmshc.h gmshFltkRun"
   cgmshFltkRun
      :: Ptr CInt
      -> IO()
gmshFltkSelectEntities :: Int -> IO(Int, [(Int,Int)])
gmshFltkSelectEntities dim = do
   let dim' = fromIntegral dim
   alloca $ \dimTags' -> do
      alloca $ \dimTags_n' -> do
         alloca $ \errptr -> do
            oval'' <- cgmshFltkSelectEntities dimTags' dimTags_n' dim' errptr
            checkErrorCodeAndThrow "gmshFltkSelectEntities" errptr
            let oval''' = fromIntegral oval''
            dimTags'' <- peekArrayPairs dimTags_n' dimTags'
            return (oval''', dimTags'')
foreign import ccall safe "gmshc.h gmshFltkSelectEntities"
   cgmshFltkSelectEntities
      :: Ptr ( Ptr CInt)
      -> Ptr CInt
      -> CInt
      -> Ptr CInt
      -> IO(CInt)
gmshFltkSelectElements :: IO(Int, [Int])
gmshFltkSelectElements = do
   alloca $ \elementTags' -> do
      alloca $ \elementTags_n' -> do
         alloca $ \errptr -> do
            oval'' <- cgmshFltkSelectElements elementTags' elementTags_n' errptr
            checkErrorCodeAndThrow "gmshFltkSelectElements" errptr
            let oval''' = fromIntegral oval''
            elementTags'' <- peekArrayInt elementTags_n' elementTags'
            return (oval''', elementTags'')
foreign import ccall safe "gmshc.h gmshFltkSelectElements"
   cgmshFltkSelectElements
      :: Ptr ( Ptr CInt)
      -> Ptr CInt
      -> Ptr CInt
      -> IO(CInt)
gmshFltkSelectViews :: IO(Int, [Int])
gmshFltkSelectViews = do
   alloca $ \viewTags' -> do
      alloca $ \viewTags_n' -> do
         alloca $ \errptr -> do
            oval'' <- cgmshFltkSelectViews viewTags' viewTags_n' errptr
            checkErrorCodeAndThrow "gmshFltkSelectViews" errptr
            let oval''' = fromIntegral oval''
            viewTags'' <- peekArrayInt viewTags_n' viewTags'
            return (oval''', viewTags'')
foreign import ccall safe "gmshc.h gmshFltkSelectViews"
   cgmshFltkSelectViews
      :: Ptr ( Ptr CInt)
      -> Ptr CInt
      -> Ptr CInt
      -> IO(CInt)
gmshOnelabSet :: String -> String -> IO()
gmshOnelabSet daatta format = do
   withCString daatta $ \daatta' -> do
      withCString format $ \format' -> do
         alloca $ \errptr -> do
            cgmshOnelabSet daatta' format' errptr
            checkErrorCodeAndThrow "gmshOnelabSet" errptr
            return ()
foreign import ccall safe "gmshc.h gmshOnelabSet"
   cgmshOnelabSet
      :: CString
      -> CString
      -> Ptr CInt
      -> IO()
gmshOnelabGet :: String -> String -> IO(String)
gmshOnelabGet name format = do
   withCString name $ \name' -> do
      withCString format $ \format' -> do
         alloca $ \daatta' -> do
            alloca $ \errptr -> do
               cgmshOnelabGet daatta' name' format' errptr
               checkErrorCodeAndThrow "gmshOnelabGet" errptr
               daatta'' <- peek daatta'
               daatta''' <- peekCString daatta''
               return (daatta''')
foreign import ccall safe "gmshc.h gmshOnelabGet"
   cgmshOnelabGet
      :: Ptr CString
      -> CString
      -> CString
      -> Ptr CInt
      -> IO()
gmshOnelabSetNumber :: String -> [Double] -> IO()
gmshOnelabSetNumber name value = do
   withCString name $ \name' -> do
      withArrayDoubleLen value $ \value_n' value' -> do
         alloca $ \errptr -> do
            cgmshOnelabSetNumber name' value' value_n' errptr
            checkErrorCodeAndThrow "gmshOnelabSetNumber" errptr
            return ()
foreign import ccall safe "gmshc.h gmshOnelabSetNumber"
   cgmshOnelabSetNumber
      :: CString
      -> Ptr CDouble
      -> CInt
      -> Ptr CInt
      -> IO()
gmshOnelabSetString :: String -> [String] -> IO()
gmshOnelabSetString name value = do
   withCString name $ \name' -> do
      withArrayStringLen value $ \value_n' value' -> do
         alloca $ \errptr -> do
            cgmshOnelabSetString name' value' value_n' errptr
            checkErrorCodeAndThrow "gmshOnelabSetString" errptr
            return ()
foreign import ccall safe "gmshc.h gmshOnelabSetString"
   cgmshOnelabSetString
      :: CString
      -> Ptr CString
      -> CInt
      -> Ptr CInt
      -> IO()
gmshOnelabGetNumber :: String -> IO([Double])
gmshOnelabGetNumber name = do
   withCString name $ \name' -> do
      alloca $ \value' -> do
         alloca $ \value_n' -> do
            alloca $ \errptr -> do
               cgmshOnelabGetNumber name' value' value_n' errptr
               checkErrorCodeAndThrow "gmshOnelabGetNumber" errptr
               value'' <- peekArrayDouble value_n' value'
               return (value'')
foreign import ccall safe "gmshc.h gmshOnelabGetNumber"
   cgmshOnelabGetNumber
      :: CString
      -> Ptr ( Ptr CDouble)
      -> Ptr CInt
      -> Ptr CInt
      -> IO()
gmshOnelabGetString :: String -> IO([String])
gmshOnelabGetString name = do
   withCString name $ \name' -> do
      alloca $ \value' -> do
         alloca $ \value_n' -> do
            alloca $ \errptr -> do
               cgmshOnelabGetString name' value' value_n' errptr
               checkErrorCodeAndThrow "gmshOnelabGetString" errptr
               value'' <- peekArrayString value_n' value'
               return (value'')
foreign import ccall safe "gmshc.h gmshOnelabGetString"
   cgmshOnelabGetString
      :: CString
      -> Ptr ( Ptr CString)
      -> Ptr CInt
      -> Ptr CInt
      -> IO()
gmshOnelabClear :: String -> IO()
gmshOnelabClear name = do
   withCString name $ \name' -> do
      alloca $ \errptr -> do
         cgmshOnelabClear name' errptr
         checkErrorCodeAndThrow "gmshOnelabClear" errptr
         return ()
foreign import ccall safe "gmshc.h gmshOnelabClear"
   cgmshOnelabClear
      :: CString
      -> Ptr CInt
      -> IO()
gmshOnelabRun :: String -> String -> IO()
gmshOnelabRun name command = do
   withCString name $ \name' -> do
      withCString command $ \command' -> do
         alloca $ \errptr -> do
            cgmshOnelabRun name' command' errptr
            checkErrorCodeAndThrow "gmshOnelabRun" errptr
            return ()
foreign import ccall safe "gmshc.h gmshOnelabRun"
   cgmshOnelabRun
      :: CString
      -> CString
      -> Ptr CInt
      -> IO()
gmshLoggerWrite :: String -> String -> IO()
gmshLoggerWrite message level = do
   withCString message $ \message' -> do
      withCString level $ \level' -> do
         alloca $ \errptr -> do
            cgmshLoggerWrite message' level' errptr
            checkErrorCodeAndThrow "gmshLoggerWrite" errptr
            return ()
foreign import ccall safe "gmshc.h gmshLoggerWrite"
   cgmshLoggerWrite
      :: CString
      -> CString
      -> Ptr CInt
      -> IO()
gmshLoggerStart :: IO()
gmshLoggerStart = do
   alloca $ \errptr -> do
      cgmshLoggerStart errptr
      checkErrorCodeAndThrow "gmshLoggerStart" errptr
      return ()
foreign import ccall safe "gmshc.h gmshLoggerStart"
   cgmshLoggerStart
      :: Ptr CInt
      -> IO()
gmshLoggerGet :: IO([String])
gmshLoggerGet = do
   alloca $ \log' -> do
      alloca $ \log_n' -> do
         alloca $ \errptr -> do
            cgmshLoggerGet log' log_n' errptr
            checkErrorCodeAndThrow "gmshLoggerGet" errptr
            log'' <- peekArrayString log_n' log'
            return (log'')
foreign import ccall safe "gmshc.h gmshLoggerGet"
   cgmshLoggerGet
      :: Ptr ( Ptr CString)
      -> Ptr CInt
      -> Ptr CInt
      -> IO()
gmshLoggerStop :: IO()
gmshLoggerStop = do
   alloca $ \errptr -> do
      cgmshLoggerStop errptr
      checkErrorCodeAndThrow "gmshLoggerStop" errptr
      return ()
foreign import ccall safe "gmshc.h gmshLoggerStop"
   cgmshLoggerStop
      :: Ptr CInt
      -> IO()
gmshLoggerTime :: IO(Double)
gmshLoggerTime = do
   alloca $ \errptr -> do
      oval'' <- cgmshLoggerTime errptr
      checkErrorCodeAndThrow "gmshLoggerTime" errptr
      let oval''' = realToFrac oval''
      return (oval''')
foreign import ccall safe "gmshc.h gmshLoggerTime"
   cgmshLoggerTime
      :: Ptr CInt
      -> IO(CDouble)
gmshLoggerCputime :: IO(Double)
gmshLoggerCputime = do
   alloca $ \errptr -> do
      oval'' <- cgmshLoggerCputime errptr
      checkErrorCodeAndThrow "gmshLoggerCputime" errptr
      let oval''' = realToFrac oval''
      return (oval''')
foreign import ccall safe "gmshc.h gmshLoggerCputime"
   cgmshLoggerCputime
      :: Ptr CInt
      -> IO(CDouble)
